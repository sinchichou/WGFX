'use strict';

// @generated by Peggy 5.0.6.
//
// https://peggyjs.org/


class peg$SyntaxError extends SyntaxError {
    constructor(message, expected, found, location) {
        super(message);
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";
    }

    static buildMessage(expected, found) {
        function hex(ch) {
            return ch.codePointAt(0).toString(16).toUpperCase();
        }

        const nonPrintable = Object.prototype.hasOwnProperty.call(RegExp.prototype, "unicode")
            ? new RegExp("[\\p{C}\\p{Mn}\\p{Mc}]", "gu")
            : null;

        function unicodeEscape(s) {
            if (nonPrintable) {
                return s.replace(nonPrintable, ch => "\\u{" + hex(ch) + "}");
            }
            return s;
        }

        function literalEscape(s) {
            return unicodeEscape(s
                .replace(/\\/g, "\\\\")
                .replace(/"/g, "\\\"")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g, ch => "\\x0" + hex(ch))
                .replace(/[\x10-\x1F\x7F-\x9F]/g, ch => "\\x" + hex(ch)));
        }

        function classEscape(s) {
            return unicodeEscape(s
                .replace(/\\/g, "\\\\")
                .replace(/\]/g, "\\]")
                .replace(/\^/g, "\\^")
                .replace(/-/g, "\\-")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g, ch => "\\x0" + hex(ch))
                .replace(/[\x10-\x1F\x7F-\x9F]/g, ch => "\\x" + hex(ch)));
        }

        const DESCRIBE_EXPECTATION_FNS = {
            literal(expectation) {
                return "\"" + literalEscape(expectation.text) + "\"";
            },

            class(expectation) {
                const escapedParts = expectation.parts.map(
                    part => (Array.isArray(part)
                        ? classEscape(part[0]) + "-" + classEscape(part[1])
                        : classEscape(part))
                );

                return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]" + (expectation.unicode ? "u" : "");
            },

            any() {
                return "any character";
            },

            end() {
                return "end of input";
            },

            other(expectation) {
                return expectation.description;
            },
        };

        function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }

        function describeExpected(expected) {
            const descriptions = expected.map(describeExpectation);
            descriptions.sort();

            if (descriptions.length > 0) {
                let j = 1;
                for (let i = 1; i < descriptions.length; i++) {
                    if (descriptions[i - 1] !== descriptions[i]) {
                        descriptions[j] = descriptions[i];
                        j++;
                    }
                }
                descriptions.length = j;
            }

            switch (descriptions.length) {
                case 1:
                    return descriptions[0];

                case 2:
                    return descriptions[0] + " or " + descriptions[1];

                default:
                    return descriptions.slice(0, -1).join(", ")
                        + ", or "
                        + descriptions[descriptions.length - 1];
            }
        }

        function describeFound(found) {
            return found ? "\"" + literalEscape(found) + "\"" : "end of input";
        }

        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    }

    format(sources) {
        let str = "Error: " + this.message;
        if (this.location) {
            let src = null;
            const st = sources.find(s => s.source === this.location.source);
            if (st) {
                src = st.text.split(/\r\n|\n|\r/g);
            }
            const s = this.location.start;
            const offset_s = (this.location.source && (typeof this.location.source.offset === "function"))
                ? this.location.source.offset(s)
                : s;
            const loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
            if (src) {
                const e = this.location.end;
                const filler = "".padEnd(offset_s.line.toString().length, " ");
                const line = src[s.line - 1];
                const last = s.line === e.line ? e.column : line.length + 1;
                const hatLen = (last - s.column) || 1;
                str += "\n --> " + loc + "\n"
                    + filler + " |\n"
                    + offset_s.line + " | " + line + "\n"
                    + filler + " | " + "".padEnd(s.column - 1, " ")
                    + "".padEnd(hatLen, "^");
            } else {
                str += "\n at " + loc;
            }
        }
        return str;
    }
}

function peg$parse(input, options) {
    options = options !== undefined ? options : {};

    const peg$FAILED = {};
    const peg$source = options.grammarSource;

    const peg$startRuleFunctions = {
        start: peg$parsestart,
    };
    let peg$startRuleFunction = peg$parsestart;

    const peg$c0 = "\n";
    const peg$c1 = "//!";

    const peg$r0 = /^[^\n]/;
    const peg$r1 = /^[a-zA-Z0-9_]/;
    const peg$r2 = /^[ \t]/;

    const peg$e0 = peg$literalExpectation("\n", false);
    const peg$e1 = peg$literalExpectation("//!", false);
    const peg$e2 = peg$classExpectation(["\n"], true, false, false);
    const peg$e3 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_"], false, false, false);
    const peg$e4 = peg$classExpectation([" ", "\t"], false, false, false);

    function peg$f0() {
        // Commit the last block if it was a PASS and had accumulated code.
        // å¦‚æœæœ€å¾Œä¸€å€‹å€å¡Šæ˜¯ PASS ä¸¦ä¸”æœ‰ç´¯ç©çš„ç¨‹å¼ç¢¼ï¼Œå‰‡æäº¤å®ƒã€‚
        if (currentBlock === 'PASS' && passCodeBuffer.length > 0) {
            currentData.code = passCodeBuffer.join('\n');
        }
        // Commit any remaining current block data.
        // æäº¤ä»»ä½•å‰©é¤˜çš„ç•¶å‰å€å¡Šè³‡æ–™ã€‚
        if (currentData) commitBlock(currentBlock, currentData);
        return shaderInfo;
    }

    function peg$f1() {
        return {type: "empty"};
    }

    function peg$f2(name, value) {
        const directive = name.toUpperCase();
        const val = value.trim();

        // Handle the 'END' directive, which explicitly closes the current block.
        // è™•ç† 'END' æŒ‡ä»¤ï¼Œå®ƒæœƒæ˜ç¢ºé—œé–‰ç•¶å‰å€å¡Šã€‚
        if (directive === 'END') {
            // If a PASS block was active, commit its accumulated code.
            // å¦‚æœ PASS å€å¡Šè™•æ–¼æ´»å‹•ç‹€æ…‹ï¼Œå‰‡æäº¤å…¶ç´¯ç©çš„ç¨‹å¼ç¢¼ã€‚
            if (currentBlock === 'PASS' && passCodeBuffer.length > 0) {
                currentData.code = passCodeBuffer.join('\n');
                passCodeBuffer = [];
            }
            // Commit any remaining current block data before ending.
            // åœ¨çµæŸå‰æäº¤ä»»ä½•å‰©é¤˜çš„ç•¶å‰å€å¡Šè³‡æ–™ã€‚
            if (currentData) {
                commitBlock(currentBlock, currentData);
            }
            currentBlock = null;
            currentData = null;
            return {type: "directive", directive: "END"};
        }

        // Check for block-starting directives.
        // æª¢æŸ¥å€å¡Šèµ·å§‹æŒ‡ä»¤ã€‚
        if (["PARAMETER", "TEXTURE", "SAMPLER", "COMMON", "PASS", "VERSION", "SORT_NAME", "USE", "CAPABILITY"].includes(directive)) {
            // If we were in a PASS block, commit its code first before starting a new block.
            // å¦‚æœæˆ‘å€‘åœ¨ PASS å€å¡Šä¸­ï¼Œå‰‡åœ¨é–‹å§‹æ–°å€å¡Šä¹‹å‰å…ˆæäº¤å…¶ç¨‹å¼ç¢¼ã€‚
            if (currentBlock === 'PASS' && passCodeBuffer.length > 0) {
                currentData.code = passCodeBuffer.join('\n');
                passCodeBuffer = [];
            }
            // Commit the data of the previous block.
            // æäº¤å‰ä¸€å€‹å€å¡Šçš„è³‡æ–™ã€‚
            if (currentData) {
                commitBlock(currentBlock, currentData);
            }

            // Start a new block based on the directive.
            // æ ¹æ“šæŒ‡ä»¤é–‹å§‹ä¸€å€‹æ–°å€å¡Šã€‚
            if (["PARAMETER", "TEXTURE", "SAMPLER", "COMMON", "PASS"].includes(directive)) {
                currentBlock = directive;
                currentData = {id: val, lines: []}; // Initialize currentData for the new block.
                if (directive === 'PASS') currentData.index = parseInt(val, 10); // Special handling for PASS index.
            } else { // Global directives (VERSION, SORT_NAME, USE, CAPABILITY) are self-contained and don't start a multi-line block.
                currentBlock = null;
                currentData = null;
                commitBlock(directive, {id: val}); // Commit immediately as they are single-line directives.
            }
        } else { // This is a sub-directive within an active block.
            // If there's no active block, this sub-directive is out of place.
            // å¦‚æœæ²’æœ‰æ´»å‹•å€å¡Šï¼Œå‰‡æ­¤å­æŒ‡ä»¤æ”¾ç½®ä¸ç•¶ã€‚
            if (!currentData) throw new Error(`Directive //! ${directive} cannot be used here / æŒ‡ä»¤ //! ${directive} ä¸èƒ½åœ¨æ­¤è™•ä½¿ç”¨`);
            parseSubDirective(currentData, directive, val); // Parse the sub-directive.
        }
        return {type: "directive", directive: directive, value: val};
    }

    function peg$f3(text) {
        const lineStr = text.join("");
        const trimmedLine = lineStr.trim();

        // Special handling for resource declarations in TEXTURE, SAMPLER, PARAMETER blocks.
        // å°æ–¼ TEXTURE, SAMPLER, PARAMETER å€å¡Šä¸­çš„è³‡æºå®£å‘Šé€²è¡Œç‰¹æ®Šè™•ç†ã€‚
        if (currentBlock === 'TEXTURE' || currentBlock === 'SAMPLER' || currentBlock === 'PARAMETER') {
            const match = trimmedLine.match(/var\s+([a-zA-Z0-9_]+)\s*:/); // Regex to find variable declaration.
            if (match) {
                currentData.isTemplate = true; // Mark as a template for resource creation.
                const name = match[1]; // Extract the resource name.
                const newResource = {...currentData, name: name, id: name}; // Create a new resource object.
                delete newResource.lines; // These are specific to COMMON blocks.
                delete newResource.isTemplate;

                // Push the new resource to the appropriate shaderInfo array.
                // å°‡æ–°è³‡æºæ¨é€åˆ°ç›¸æ‡‰çš„ shaderInfo é™£åˆ—ä¸­ã€‚
                if (currentBlock === 'TEXTURE') {
                    shaderInfo.textures.push(newResource);
                } else if (currentBlock === 'SAMPLER') {
                    shaderInfo.samplers.push(newResource);
                } else if (currentBlock === 'PARAMETER') {
                    shaderInfo.parameters.push(newResource);
                }
                return {type: "code", text: lineStr};
            }
        }

        // Accumulate code lines for COMMON and PASS blocks.
        // ç´¯ç© COMMON å’Œ PASS å€å¡Šçš„ç¨‹å¼ç¢¼è¡Œã€‚
        if (currentBlock === 'COMMON') {
            currentData.lines.push(lineStr);
        } else if (currentBlock === 'PASS') {
            passCodeBuffer.push(lineStr);
        }
        return {type: "code", text: lineStr};
    }

    let peg$currPos = options.peg$currPos | 0;
    const peg$posDetailsCache = [{line: 1, column: 1}];
    let peg$maxFailPos = peg$currPos;
    let peg$maxFailExpected = options.peg$maxFailExpected || [];
    let peg$silentFails = options.peg$silentFails | 0;

    let peg$result;

    if (options.startRule) {
        if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function peg$getUnicode(pos = peg$currPos) {
        const cp = input.codePointAt(pos);
        if (cp === undefined) {
            return "";
        }
        return String.fromCodePoint(cp);
    }

    function peg$literalExpectation(text, ignoreCase) {
        return {type: "literal", text, ignoreCase};
    }

    function peg$classExpectation(parts, inverted, ignoreCase, unicode) {
        return {type: "class", parts, inverted, ignoreCase, unicode};
    }

    function peg$endExpectation() {
        return {type: "end"};
    }

    function peg$computePosDetails(pos) {
        let details = peg$posDetailsCache[pos];
        let p;

        if (details) {
            return details;
        } else {
            if (pos >= peg$posDetailsCache.length) {
                p = peg$posDetailsCache.length - 1;
            } else {
                p = pos;
                while (!peg$posDetailsCache[--p]) {
                }
            }

            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column,
            };

            while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                } else {
                    details.column++;
                }

                p++;
            }

            peg$posDetailsCache[pos] = details;

            return details;
        }
    }

    function peg$computeLocation(startPos, endPos, offset) {
        const startPosDetails = peg$computePosDetails(startPos);
        const endPosDetails = peg$computePosDetails(endPos);

        const res = {
            source: peg$source,
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column,
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column,
            },
        };
        return res;
    }

    function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
            return;
        }

        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
    }

    function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(
            peg$SyntaxError.buildMessage(expected, found),
            expected,
            found,
            location
        );
    }

    function peg$parsestart() {
        let s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseline();
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseline();
        }
        s1 = peg$f0();
        s0 = s1;

        return s0;
    }

    function peg$parseline() {
        let s0, s1;

        s0 = peg$parsedirective_line();
        if (s0 === peg$FAILED) {
            s0 = peg$parsecode_line();
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 10) {
                    s1 = peg$c0;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e0);
                    }
                }
                if (s1 !== peg$FAILED) {
                    s1 = peg$f1();
                }
                s0 = s1;
            }
        }

        return s0;
    }

    function peg$parsedirective_line() {
        let s0, s1, s3, s5;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c1) {
            s1 = peg$c1;
            peg$currPos += 3;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e1);
            }
        }
        if (s1 !== peg$FAILED) {
            peg$parse_();
            s3 = peg$parseidentifier();
            if (s3 !== peg$FAILED) {
                peg$parse_();
                s5 = peg$parserest_of_line();
                s0 = peg$f2(s3, s5);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }

        return s0;
    }

    function peg$parsecode_line() {
        let s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = input.charAt(peg$currPos);
        if (peg$r0.test(s2)) {
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e2);
            }
        }
        if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = input.charAt(peg$currPos);
                if (peg$r0.test(s2)) {
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e2);
                    }
                }
            }
        } else {
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 10) {
                s2 = peg$c0;
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                }
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            s0 = peg$f3(s1);
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }

        return s0;
    }

    function peg$parseidentifier() {
        let s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = input.charAt(peg$currPos);
        if (peg$r1.test(s2)) {
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e3);
            }
        }
        if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = input.charAt(peg$currPos);
                if (peg$r1.test(s2)) {
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                    }
                }
            }
        } else {
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
        } else {
            s0 = s1;
        }

        return s0;
    }

    function peg$parserest_of_line() {
        let s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = input.charAt(peg$currPos);
        if (peg$r0.test(s2)) {
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e2);
            }
        }
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = input.charAt(peg$currPos);
            if (peg$r0.test(s2)) {
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                }
            }
        }
        s0 = input.substring(s0, peg$currPos);

        return s0;
    }

    function peg$parse_() {
        let s0, s1;

        s0 = [];
        s1 = input.charAt(peg$currPos);
        if (peg$r2.test(s1)) {
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e4);
            }
        }
        while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = input.charAt(peg$currPos);
            if (peg$r2.test(s1)) {
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e4);
                }
            }
        }

        return s0;
    }


    // Initialize the Intermediate Representation (IR) structure.
    // åˆå§‹åŒ– IR çµæ§‹
    const shaderInfo = {
        metadata: {use: {}, capability: {}},
        parameters: [],
        textures: [],
        samplers: [],
        passes: [],
        commonCode: ''
    };

    // Tracks the currently active block type (e.g., 'PARAMETER', 'TEXTURE', 'PASS').
    // è¿½è¹¤ç•¶å‰æ´»å‹•çš„å€å¡Šé¡å‹ (ä¾‹å¦‚ï¼š'PARAMETER', 'TEXTURE', 'PASS')ã€‚
    let currentBlock = null;
    // Stores data for the current block being parsed.
    // å„²å­˜ç•¶å‰æ­£åœ¨è§£æçš„å€å¡Šè³‡æ–™ã€‚
    let currentData = null;
    // Buffer to accumulate code lines within a 'PASS' block.
    // ç”¨æ–¼åœ¨ 'PASS' å€å¡Šå…§ç´¯ç©ç¨‹å¼ç¢¼è¡Œçš„ç·©è¡å€ã€‚
    let passCodeBuffer = [];

    /**
     * Commits the parsed data of a block to the main shaderInfo structure.
     * å°‡è§£æå¾Œçš„å€å¡Šè³‡æ–™æäº¤åˆ°ä¸»è¦çš„ shaderInfo çµæ§‹ä¸­ã€‚
     * @param {string} blockType - The type of the block (e.g., 'PARAMETER', 'COMMON').
     * @param {object} data - The parsed data for the block.
     */
    function commitBlock(blockType, data) {
        if (!blockType || !data || data.isTemplate) {
            currentData = null;
            return;
        }
        switch (blockType) {
            case 'PARAMETER':
                shaderInfo.parameters.push(data);
                break;
            case 'COMMON':
                shaderInfo.commonCode = data.lines.join('\n');
                break;
            case 'TEXTURE':
                shaderInfo.textures.push(data);
                break;
            case 'SAMPLER':
                shaderInfo.samplers.push(data);
                break;
            case 'PASS':
                shaderInfo.passes.push(data);
                break;
            case 'VERSION':
                shaderInfo.metadata.version = parseInt(data.id, 10);
                break;
            case 'SORT_NAME':
                shaderInfo.metadata.sortName = data.id;
                break;
            case 'USE':
                data.id.split(',').forEach(f => shaderInfo.metadata.use[f.trim().toUpperCase()] = true);
                break;
            case 'CAPABILITY':
                data.id.split(',').forEach(f => shaderInfo.metadata.capability[f.trim().toUpperCase()] = true);
                break;
        }
        currentData = null;
    }

    /**
     * Parses sub-directives within a block (e.g., //! DEFAULT, //! MIN for PARAMETER).
     * è§£æå€å¡Šå…§éƒ¨çš„å­æŒ‡ä»¤ (ä¾‹å¦‚ PARAMETER çš„ //! DEFAULT, //! MIN)ã€‚
     * @param {object} data - The current block's data object to populate.
     * @param {string} directive - The name of the sub-directive.
     * @param {string} value - The value of the sub-directive.
     */
    function parseSubDirective(data, directive, value) {
        const key = directive.toLowerCase();
        switch (key) {
            case 'in':
            case 'out':
                data[key] = value.split(',').map(s => s.trim());
                break;
            case 'block_size':
                data.blockSize = value.split(',').map(Number);
                if (data.blockSize.length === 1) data.blockSize.push(data.blockSize[0]); // Handle single value for block_size
                break;
            case 'num_threads':
                data.numThreads = value.split(',').map(Number);
                while (data.numThreads.length < 3) data.numThreads.push(1); // Ensure 3 components for num_threads
                break;
            case 'default':
            case 'min':
            case 'max':
            case 'step':
                data[key] = parseFloat(value);
                break;
            case 'format':
                data[key] = value.toLowerCase() === 'r16g16b16a16_float' ? 'rgba16float' : value;
                break;
            default:
                data[key] = value;
        }
    }

    peg$result = peg$startRuleFunction();

    const peg$success = (peg$result !== peg$FAILED && peg$currPos === input.length);

    function peg$throw() {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input.length ? peg$getUnicode(peg$maxFailPos) : null,
            peg$maxFailPos < input.length
                ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
                : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
    }

    if (options.peg$library) {
        return /** @type {any} */ ({
            peg$result,
            peg$currPos,
            peg$FAILED,
            peg$maxFailExpected,
            peg$maxFailPos,
            peg$success,
            peg$throw: peg$success ? undefined : peg$throw,
        });
    }
    if (peg$success) {
        return peg$result;
    } else {
        peg$throw();
    }
}

// src/runtime/ResourceManager.js

/**
 * @fileoverview
 * - EN: Manages the creation, storage, and retrieval of WebGPU resources.
 *   This class handles GPUTexture, GPUSampler, and GPUBuffer objects based on the shader IR,
 *   providing a central location to access these resources by name.
 * - TW: ç®¡ç† WebGPU è³‡æºçš„å»ºç«‹ã€å„²å­˜å’Œæª¢ç´¢ã€‚
 *   æ­¤é¡åˆ¥æ ¹æ“šè‘—è‰²å™¨ IR è™•ç† GPUTextureã€GPUSampler å’Œ GPUBuffer ç‰©ä»¶ï¼Œ
 *   æä¾›ä¸€å€‹ä¸­å¿ƒä½ç½®ï¼Œå¯ä»¥æŒ‰åç¨±å­˜å–é€™äº›è³‡æºã€‚
 */

let GPUDevice$1, GPUTextureUsage, GPUBufferUsage;

/**
 * - EN: In a Node.js environment, native WebGPU objects don't exist.
 *   We check for their existence on the global scope. If they don't exist,
 *   they will remain `undefined`, which is safe for the CLI code path
 *   as it doesn't instantiate or use any GPU-related objects.
 * - TW: åœ¨ Node.js ç’°å¢ƒä¸­ï¼ŒåŸç”Ÿ WebGPU ç‰©ä»¶ä¸å­˜åœ¨ã€‚
 *   æˆ‘å€‘æª¢æŸ¥å®ƒå€‘æ˜¯å¦åœ¨å…¨åŸŸç¯„åœå…§å­˜åœ¨ã€‚å¦‚æœä¸å­˜åœ¨ï¼Œ
 *   å®ƒå€‘å°‡ä¿æŒ `undefined`ï¼Œé€™å°æ–¼ CLI ç¨‹å¼ç¢¼è·¯å¾‘æ˜¯å®‰å…¨çš„ï¼Œ
 *   å› ç‚ºå®ƒä¸å¯¦ä¾‹åŒ–æˆ–ä½¿ç”¨ä»»ä½•èˆ‡ GPU ç›¸é—œçš„ç‰©ä»¶ã€‚
 */
try {
    /**
     * - EN: This will only succeed in a browser-like environment with WebGPU support.
     * - TW: é€™åªæœƒåœ¨æ”¯æ´ WebGPU çš„ç€è¦½å™¨ç’°å¢ƒä¸­æˆåŠŸã€‚
     */
    if (globalThis.GPUDevice) {
        GPUDevice$1 = globalThis.GPUDevice;
        GPUTextureUsage = globalThis.GPUTextureUsage;
        GPUBufferUsage = globalThis.GPUBufferUsage;
    }
    /**
     * - EN: In Node.js or a non-WebGPU environment, these will remain undefined.
     *   This is safe because the CLI path does not use this functionality.
     * - TW: åœ¨ Node.js æˆ–é WebGPU ç’°å¢ƒä¸­ï¼Œé€™äº›å°‡ä¿æŒæœªå®šç¾©ã€‚
     *   é€™å¾ˆå®‰å…¨ï¼Œå› ç‚º CLI è·¯å¾‘ä¸ä½¿ç”¨æ­¤åŠŸèƒ½ã€‚
     */
} catch (e) {
    /**
     * - EN: Ignore any errors during this detection phase.
     *   The variables will simply remain undefined.
     * - TW: åœ¨æ­¤æª¢æ¸¬éšæ®µå¿½ç•¥ä»»ä½•éŒ¯èª¤ã€‚
     *   è®Šæ•¸å°‡ç°¡å–®åœ°ä¿æŒæœªå®šç¾©ã€‚
     */
}


/**
 * - EN: ResourceManager Implementation
 * - TW: è³‡æºç®¡ç†å™¨å¯¦ä½œ
 */

class ResourceManager {
    /**
     * @param {GPUDevice} [device]
     * - EN: The active WebGPU device. If not provided, a mock device will be used.
     * - TW: ä½œç”¨ä¸­çš„ WebGPU è£ç½®ã€‚å¦‚æœæœªæä¾›ï¼Œå°‡ä½¿ç”¨æ¨¡æ“¬è£ç½®ã€‚
     */
    constructor(device) {
        /** @type {GPUDevice} */
        /**
         * - EN: Use provided device or a mock device.
         * - TW: ä½¿ç”¨æä¾›çš„è£ç½®æˆ–æ¨¡æ“¬è£ç½®ã€‚
         */
        this.device = device || new GPUDevice$1();
        /**
         * - EN: Stores GPUTexture objects, mapped by their unique names.
         * - TW: å„²å­˜ GPUTexture ç‰©ä»¶ï¼ŒæŒ‰å…¶å”¯ä¸€åç¨±æ˜ å°„ã€‚
         * @type {Map<string, import('./WebGPU-mock.js').GPUTexture>}
         */
        this.textures = new Map();
        /**
         * - EN: Stores GPUSampler objects, mapped by their unique names.
         * - TW: å„²å­˜ GPUSampler ç‰©ä»¶ï¼ŒæŒ‰å…¶å”¯ä¸€åç¨±æ˜ å°„ã€‚
         * @type {Map<string, import('./WebGPU-mock.js').GPUSampler>}
         */
        this.samplers = new Map();
        /**
         * - EN: Stores metadata for each uniform, including its offset and size within the main buffer.
         * - TW: å„²å­˜æ¯å€‹ uniform çš„å…ƒè³‡æ–™ï¼ŒåŒ…æ‹¬å…¶åœ¨ä¸»ç·©è¡å€ä¸­çš„åç§»é‡å’Œå¤§å°ã€‚
         * @type {Map<string, {buffer: import('./WebGPU-mock.js').GPUBuffer, offset: number, size: number}>}
         */
        this.uniforms = new Map();
        /**
         * - EN: A single GPU buffer used to store all uniform parameters.
         * - TW: ç”¨æ–¼å„²å­˜æ‰€æœ‰ uniform åƒæ•¸çš„å–®ä¸€ GPU ç·©è¡å€ã€‚
         * @type {import('./WebGPU-mock.js').GPUBuffer}
         */
        this.uniformBuffer = null;
    }

    /**
     * - EN: Initializes all GPU resources based on the parsed shader IR.
     * - TW: æ ¹æ“šè§£æå¾Œçš„è‘—è‰²å™¨ IR åˆå§‹åŒ–æ‰€æœ‰ GPU è³‡æºã€‚
     * @param {import('./ShaderParser.js').WGFXShaderInfo} shaderInfo
     * - EN: Parsed shader information from Parser.js.
     * - TW: ä¾†è‡ª Parser.js çš„è§£æå¾Œè‘—è‰²å™¨è³‡è¨Šã€‚
     */

    /**
     * - EN: Initializes all GPU resources based on the parsed shader IR.
     * - TW: æ ¹æ“šè§£æå¾Œçš„è‘—è‰²å™¨ IR åˆå§‹åŒ–æ‰€æœ‰ GPU è³‡æºã€‚
     * @param {import('./ShaderParser.js').WGFXShaderInfo} shaderInfo
     * - EN: Parsed shader information from Parser.js.
     * - TW: ä¾†è‡ª Parser.js çš„è§£æå¾Œè‘—è‰²å™¨è³‡è¨Šã€‚
     */
    /**
     * - EN: Initializes all GPU resources based on the parsed shader IR.
     * - TW: æ ¹æ“šè§£æå¾Œçš„è‘—è‰²å™¨ IR åˆå§‹åŒ–æ‰€æœ‰ GPU è³‡æºã€‚
     * @param {import('./ShaderParser.js').WGFXShaderInfo} shaderInfo
     * - EN: Parsed shader information from Parser.js.
     * - TW: ä¾†è‡ª Parser.js çš„è§£æå¾Œè‘—è‰²å™¨è³‡è¨Šã€‚
     */
    initialize(shaderInfo, externalResources = {}) {
        const context = {};

        // 1. [å„ªå…ˆ] è¼‰å…¥å¤–éƒ¨å®šç¾©çš„å¸¸æ•¸ (å¦‚ INPUT_WIDTH/HEIGHT)
        if (externalResources.defines) {
            Object.assign(context, externalResources.defines);
        }

        // 2. å»ºç«‹å¤–éƒ¨ç´‹ç† (INPUT, OUTPUT ç­‰)
        if (externalResources.textures) {
            for (const [name, descriptor] of Object.entries(externalResources.textures)) {
                this.createTexture(name, descriptor);
            }
        }

        // 3. [å¾Œå‚™] å¦‚æœ defines æ²’çµ¦å°ºå¯¸ï¼Œå˜—è©¦å¾å‰›å‰›å»ºç«‹çš„ INPUT ç´‹ç†åæŸ¥
        if ((!context['INPUT_WIDTH'] || !context['INPUT_HEIGHT']) && this.textures.has('INPUT')) {
            const inputTexture = this.getTexture('INPUT');
            if (inputTexture) {
                if (!context['INPUT_WIDTH']) context['INPUT_WIDTH'] = inputTexture.width;
                if (!context['INPUT_HEIGHT']) context['INPUT_HEIGHT'] = inputTexture.height;
            }
        }

        // --- Safe Math Parser (CSP Compliant: No eval/new Function) ---
        // å¯¦ä½œä¸€å€‹ç°¡å–®çš„éè¿´ä¸‹é™è§£æå™¨ï¼Œæ”¯æ´ +, -, *, /, %, () å’Œå°æ•¸
        const parseMathExpression = (str) => {
            let pos = 0;
            // ç§»é™¤æ‰€æœ‰ç©ºç™½
            str = str.replace(/\s+/g, '');

            const peek = () => str[pos];
            const consume = () => str[pos++];

            const parseFactor = () => {
                if (peek() === '(') {
                    consume(); // åƒæ‰ '('
                    const result = parseExpr();
                    if (peek() !== ')') throw new Error("Expected ')'");
                    consume(); // åƒæ‰ ')'
                    return result;
                }

                // è§£ææ•¸å­— (å«è² è™Ÿå’Œå°æ•¸é»)
                let numStr = '';
                if (peek() === '-') {
                    numStr += consume();
                }
                while (pos < str.length && (/[0-9.]/).test(peek())) {
                    numStr += consume();
                }
                if (numStr === '') throw new Error(`Unexpected char: '${peek()}' at pos ${pos}`);
                return parseFloat(numStr);
            };

            const parseTerm = () => {
                let left = parseFactor();
                while (pos < str.length) {
                    const op = peek();
                    if (op === '*' || op === '/' || op === '%') {
                        consume();
                        const right = parseFactor();
                        if (op === '*') left *= right;
                        else if (op === '/') left /= right;
                        else if (op === '%') left %= right;
                    } else {
                        break;
                    }
                }
                return left;
            };

            const parseExpr = () => {
                let left = parseTerm();
                while (pos < str.length) {
                    const op = peek();
                    if (op === '+' || op === '-') {
                        consume();
                        const right = parseTerm();
                        if (op === '+') left += right;
                        else if (op === '-') left -= right;
                    } else {
                        break;
                    }
                }
                return left;
            };

            const result = parseExpr();
            return result;
        };

        const evaluate = (expr, ctx) => {
            if (typeof expr !== 'string') return expr;

            // æ›¿æ›è®Šæ•¸
            let evaluatedExpr = expr;
            for (const key in ctx) {
                const regex = new RegExp('\\b' + key + '\\b', 'g');
                evaluatedExpr = evaluatedExpr.replace(regex, ctx[key]);
            }

            try {
                // å¦‚æœæ›¿æ›å¾Œåªæ˜¯å–®ç´”çš„æ•¸å­—å­—ä¸²ï¼Œç›´æ¥è½‰æ› (æœ€å¿«)
                if (!isNaN(Number(evaluatedExpr))) {
                    return Math.ceil(Number(evaluatedExpr));
                }
                // å¦å‰‡ä½¿ç”¨å®‰å…¨çš„è§£æå™¨è¨ˆç®—
                return Math.ceil(parseMathExpression(evaluatedExpr));
            } catch (e) {
                console.error("Evaluation failed. Context:", ctx);
                throw new Error(`Cannot evaluate expression: "${expr}". Resulted in: "${evaluatedExpr}". Error: ${e.message}`);
            }
        };

        /**
         * - EN: Create textures defined in the shader.
         * - TW: å»ºç«‹è‘—è‰²å™¨ä¸­å®šç¾©çš„ç´‹ç†ã€‚
         */
        shaderInfo.textures.forEach(tex => {
            if (this.textures.has(tex.name)) return; // Already created externally

            const width = evaluate(tex.width, context);
            const height = evaluate(tex.height, context);

            if (!width || !height) {
                throw new Error(`Could not determine size for texture ${tex.name}. Width or height expression is invalid.`);
            }

            const descriptor = {
                size: [width, height],
                format: tex.format?.toLowerCase() || 'rgba8unorm',
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
            };
            this.createTexture(tex.name, descriptor);
        });

        /**
         * - EN: Create samplers defined in the shader.
         * - TW: å»ºç«‹è‘—è‰²å™¨ä¸­å®šç¾©çš„å–æ¨£å™¨ã€‚
         */
        shaderInfo.samplers.forEach(samp => {
            const descriptor = {
                magFilter: samp.filter === 'LINEAR' ? 'linear' : 'nearest',
                minFilter: samp.filter === 'LINEAR' ? 'linear' : 'nearest',
                addressModeU: samp.address === 'WRAP' ? 'repeat' : 'clamp-to-edge',
                addressModeV: samp.address === 'WRAP' ? 'repeat' : 'clamp-to-edge',
            };
            this.createSampler(samp.name, descriptor);
        });

        /**
         * - EN: Create a single uniform buffer to store all parameters.
         * - TW: å»ºç«‹ä¸€å€‹å–®ä¸€çš„ uniform ç·©è¡å€ä¾†å„²å­˜æ‰€æœ‰åƒæ•¸ã€‚
         */
        if (shaderInfo.parameters.length > 0) {
            let totalSize = 0;
            shaderInfo.parameters.forEach(param => {
                const size = 4; // Assuming 4 bytes (f32/i32) for simplicity
                this.uniforms.set(param.name, {buffer: null, offset: totalSize, size});
                totalSize += size;
            });

            const alignedSize = Math.ceil(totalSize / 16) * 16;

            this.uniformBuffer = this.device.createBuffer({
                size: alignedSize,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });

            this.uniforms.forEach(u => u.buffer = this.uniformBuffer);
        }

        console.log("ResourceManager: Resources initialized.", {
            textures: [...this.textures.keys()],
            samplers: [...this.samplers.keys()],
            uniforms: [...this.uniforms.keys()],
            context: context
        });
    }
    /**
     * - EN: Creates or replaces a GPUTexture in the manager.
     * - TW: åœ¨ç®¡ç†å™¨ä¸­å»ºç«‹æˆ–æ›¿æ› GPUTextureã€‚
     * @param {string} name
     * - EN: The unique name of the texture.
     * - TW: ç´‹ç†çš„å”¯ä¸€åç¨±ã€‚
     * @param {GPUTextureDescriptor} descriptor
     * - EN: The descriptor for the texture.
     * - TW: ç´‹ç†æè¿°ç¬¦ã€‚
     * @returns {GPUTexture}
     * - EN: The created GPUTexture.
     * - TW: å»ºç«‹çš„ GPUTextureã€‚
     */
    createTexture(name, descriptor) {
        /**
         * - EN: If a texture with the same name exists, destroy the old one first.
         * - TW: å¦‚æœå­˜åœ¨åŒåç´‹ç†ï¼Œå‰‡å…ˆéŠ·æ¯€èˆŠç´‹ç†ã€‚
         */
        if (this.textures.has(name)) {
            this.textures.get(name).destroy();
        }
        const texture = this.device.createTexture(descriptor);
        /**
         * - EN: Set label for debugging.
         * - TW: è¨­å®šæ¨™ç±¤ä»¥é€²è¡Œèª¿è©¦ã€‚
         */
        texture.label = name;
        this.textures.set(name, texture);
        return texture;
    }

    /**
     * - EN: Retrieves a texture by its name.
     * - TW: æŒ‰åç¨±æª¢ç´¢ç´‹ç†ã€‚
     * @param {string} name
     * - EN: The name of the texture.
     * - TW: ç´‹ç†çš„åç¨±ã€‚
     * @returns {GPUTexture | undefined}
     * - EN: The texture object or undefined if not found.
     * - TW: ç´‹ç†ç‰©ä»¶ï¼Œå¦‚æœæ‰¾ä¸åˆ°å‰‡ç‚º undefinedã€‚
     */
    getTexture(name) {
        return this.textures.get(name);
    }

    /**
     * - EN: Creates a new GPUSampler.
     * - TW: å»ºç«‹æ–°çš„ GPUSamplerã€‚
     * @param {string} name
     * - EN: The unique name of the sampler.
     * - TW: å–æ¨£å™¨çš„å”¯ä¸€åç¨±ã€‚
     * @param {GPUSamplerDescriptor} descriptor
     * - EN: The descriptor for the sampler.
     * - TW: å–æ¨£å™¨æè¿°ç¬¦ã€‚
     * @returns {GPUSampler}
     * - EN: The created GPUSampler.
     * - TW: å»ºç«‹çš„ GPUSamplerã€‚
     */
    createSampler(name, descriptor) {
        const sampler = this.device.createSampler(descriptor);
        this.samplers.set(name, sampler);
        return sampler;
    }

    /**
     * - EN: Uploads image data (ImageBitmap, VideoFrame, etc.) to a specified GPUTexture.
     * - TW: å°‡åœ–åƒè³‡æ–™ (ImageBitmap, VideoFrame ç­‰) ä¸Šå‚³åˆ°æŒ‡å®šçš„ GPUTextureã€‚
     * @param {string} name - The name of the texture (e.g., 'INPUT').
     * @param {ImageBitmap | VideoFrame | HTMLCanvasElement} image - The source image data.
     */
    updateTextureFromImage(name, image) {
        const texture = this.getTexture(name);

        if (!texture) {
            throw new Error(`Texture '${name}' not found for update.`);
        }

        // Ensure the texture has COPY_DST usage, which is usually included for dynamic textures.
        // We assume 'INPUT' is correctly set up with the right dimensions/format during compile/external setup.

        if (texture.width !== image.width || texture.height !== image.height) {
            // In a real implementation, you might resize the texture or throw an error.
            // For simplicity, we assume the input size matches the texture size (e.g., INPUT is pre-sized).
            console.warn(`Input image size (${image.width}x${image.height}) does not match texture size (${texture.width}x${texture.height}).`);
        }

        this.device.queue.copyExternalImageToBufferOrTexture(
            {source: image},
            {texture: texture},
            [image.width, image.height]
        );
        console.log(`Texture '${name}' updated from image source.`);
    }

    /**
     * - EN: Retrieves a sampler by its name.
     * - TW: æŒ‰åç¨±æª¢ç´¢å–æ¨£å™¨ã€‚
     * @param {string} name
     * - EN: The name of the sampler.
     * - TW: å–æ¨£å™¨çš„åç¨±ã€‚
     * @returns {GPUSampler | undefined}
     * - EN: The sampler object or undefined if not found.
     * - TW: å–æ¨£å™¨ç‰©ä»¶ï¼Œå¦‚æœæ‰¾ä¸åˆ°å‰‡ç‚º undefinedã€‚
     */
    getSampler(name) {
        return this.samplers.get(name);
    }

    /**
     * - EN: Retrieves the single uniform buffer for all parameters.
     * - TW: æª¢ç´¢æ‰€æœ‰åƒæ•¸çš„å–®ä¸€ uniform ç·©è¡å€ã€‚
     * @returns {GPUBuffer | null} - EN: The uniform buffer object, or null if no parameters exist. - TW: çµ±ä¸€ç·©è¡å€ç‰©ä»¶ï¼Œå¦‚æœä¸å­˜åœ¨åƒæ•¸å‰‡ç‚º nullã€‚
     */
    getUniformBuffer() {
        return this.uniformBuffer;
    }

    /**
     * - EN: Retrieves metadata for a specific uniform.
     * - TW: æª¢ç´¢ç‰¹å®š uniform çš„å…ƒè³‡æ–™ã€‚
     * @param {string} name
     * - EN: The name of the uniform parameter.
     * - TW: uniform åƒæ•¸çš„åç¨±ã€‚
     * @returns {{buffer: GPUBuffer, offset: number, size: number} | undefined}
     * - EN: Metadata for the uniform, or undefined if not found.
     * - TW: uniform çš„å…ƒè³‡æ–™ï¼Œå¦‚æœæ‰¾ä¸åˆ°å‰‡ç‚º undefinedã€‚
     */
    getUniform(name) {
        return this.uniforms.get(name);
    }

    /**
     * - EN: Destroys all managed GPU resources to prevent memory leaks.
     * - TW: éŠ·æ¯€æ‰€æœ‰ç®¡ç†çš„ GPU è³‡æºä»¥é˜²æ­¢è¨˜æ†¶é«”æ´©æ¼ã€‚
     */
    dispose() {
        this.textures.forEach(texture => texture.destroy());
        /**
         * - EN: Destroy all GPU textures.
         * - TW: éŠ·æ¯€æ‰€æœ‰ GPU ç´‹ç†ã€‚
         */
        this.uniforms.clear();
        /**
         * - EN: Clear uniform metadata.
         * - TW: æ¸…é™¤ uniform å…ƒè³‡æ–™ã€‚
         */
        if (this.uniformBuffer) {
            this.uniformBuffer.destroy();
            /**
             * - EN: Destroy the uniform buffer.
             * - TW: éŠ·æ¯€ uniform ç·©è¡å€ã€‚
             */
        }
        this.textures.clear();
        /**
         * - EN: Clear the texture map.
         * - TW: æ¸…é™¤ç´‹ç†æ˜ å°„ã€‚
         */
        this.samplers.clear();
        /**
         * - EN: Clear the sampler map.
         * - TW: æ¸…é™¤å–æ¨£å™¨æ˜ å°„ã€‚
         */
        /**
         * - EN: All GPU resources destroyed.
         * - TW: æ‰€æœ‰ GPU è³‡æºå·²éŠ·æ¯€ã€‚
         */
        console.log("ResourceManager: All GPU resources destroyed.");
    }
}

// src/runtime/PipelineManager.js

/**
 * - EN: Manages the creation and scheduling of WebGPU compute pipelines.
 * - TW: ç®¡ç† WebGPU è¨ˆç®—ç®¡ç·šçš„å»ºç«‹å’Œèª¿åº¦ã€‚
 */
class PipelineManager {
    constructor(device, resourceManager) {
        this.device = device;
        this.resourceManager = resourceManager;
        this.pipelines = new Map();

        // Setup uncaptured error handler for debugging
        this.device.addEventListener('uncapturederror', event => {
            console.error('âŒ WebGPU Uncaptured Error:', event.error.message);
        });
    }

    /**
     * - EN: Asynchronously creates compute pipelines for all passes.
     * - TW: éåŒæ­¥å»ºç«‹æ‰€æœ‰é€šé“çš„è¨ˆç®—ç®¡ç·šã€‚
     */
    async createPipelines(shaderInfo, generatedModules) {
        this.pipelines.clear();

        for (const module of generatedModules) {
            const pass = shaderInfo.passes.find(p => p.index === module.passIndex);
            if (!pass) {
                console.warn(`PipelineManager: Pass ${module.passIndex} not found in shaderInfo.`);
                continue;
            }

            console.log(`ğŸ”§ å»ºç«‹ Pass ${module.passIndex} çš„ç®¡ç·š...`);
            console.log(`ğŸ“„ WGSL ç¨‹å¼ç¢¼é•·åº¦: ${module.wgslCode.length} å­—å…ƒ`);

            try {
                // 1. Create GPUShaderModule with error scope
                this.device.pushErrorScope('validation');

                const shaderModule = this.device.createShaderModule({
                    code: module.wgslCode,
                    label: `Pass ${module.passIndex} Shader Module`
                });

                const shaderError = await this.device.popErrorScope();
                if (shaderError) {
                    console.error(`âŒ Shader Module å»ºç«‹éŒ¯èª¤:`, shaderError.message);
                    throw shaderError;
                }

                // Check compilation info
                const compilationInfo = await shaderModule.getCompilationInfo();
                if (compilationInfo.messages.length > 0) {
                    console.group(`âš ï¸ Shader ç·¨è­¯è¨Šæ¯ (Pass ${module.passIndex}):`);
                    for (const msg of compilationInfo.messages) {
                        const level = msg.type === 'error' ? 'âŒ' : msg.type === 'warning' ? 'âš ï¸' : 'â„¹ï¸';
                        console.log(`${level} Line ${msg.lineNum}:${msg.linePos} - ${msg.message}`);

                        // Show context
                        if (msg.lineNum) {
                            const lines = module.wgslCode.split('\n');
                            const contextStart = Math.max(0, msg.lineNum - 2);
                            const contextEnd = Math.min(lines.length, msg.lineNum + 2);
                            console.log('Context:');
                            for (let i = contextStart; i < contextEnd; i++) {
                                const prefix = (i + 1) === msg.lineNum ? '>>> ' : '    ';
                                console.log(`${prefix}${i + 1}: ${lines[i]}`);
                            }
                        }
                    }
                    console.groupEnd();

                    // If there are errors, stop
                    const hasErrors = compilationInfo.messages.some(m => m.type === 'error');
                    if (hasErrors) {
                        throw new Error(`Shader compilation failed with ${compilationInfo.messages.filter(m => m.type === 'error').length} error(s)`);
                    }
                }

                console.log(`  âœ… Shader Module å»ºç«‹æˆåŠŸ`);

                // 2. Create GPUBindGroupLayout
                const bindingMap = new Map();

                // Add Samplers
                module.resources.samplers.forEach(samp => {
                    console.log(`  âœ“ Sampler "${samp.name}" -> @binding(${samp.binding})`);
                    bindingMap.set(samp.binding, {
                        binding: samp.binding,
                        visibility: GPUShaderStage.COMPUTE,
                        sampler: { type: 'filtering' }
                    });
                });

                // Add Uniforms (binding 1 if present)
                if (module.resources.parameters.length > 0) {
                    console.log(`  âœ“ Uniforms -> @binding(1)`);
                    bindingMap.set(1, {
                        binding: 1,
                        visibility: GPUShaderStage.COMPUTE,
                        buffer: { type: 'uniform' }
                    });
                }

                // Add Textures
                module.resources.textures.forEach(tex => {
                    const texType = tex.isStorage ? 'storage' : 'sampled';
                    const normalizedFormat = (tex.format || 'rgba8unorm').toLowerCase().replace(/_/g, '');
                    console.log(`  âœ“ Texture "${tex.name}" (${texType}, ${normalizedFormat}) -> @binding(${tex.binding})`);

                    if (tex.isStorage) {
                        // Validate storage format
                        const validStorageFormats = [
                            'r32float', 'r32sint', 'r32uint',
                            'rgba16float', 'rgba16sint', 'rgba16uint',
                            'rgba32float', 'rgba32sint', 'rgba32uint',
                            'rg32float', 'rg32sint', 'rg32uint',
                            'rgba8unorm', 'rgba8snorm', 'rgba8uint', 'rgba8sint' // These are for read-only
                        ];

                        // For write-only storage, only certain formats are valid
                        const validWriteStorageFormats = [
                            'r32float', 'r32sint', 'r32uint',
                            'rgba16float', 'rgba16sint', 'rgba16uint',
                            'rgba32float', 'rgba32sint', 'rgba32uint',
                            'rg32float', 'rg32sint', 'rg32uint'
                        ];

                        if (!validWriteStorageFormats.includes(normalizedFormat)) {
                            console.error(`âŒ Invalid write storage texture format: ${normalizedFormat}`);
                            console.error(`   Valid formats for write-only storage: ${validWriteStorageFormats.join(', ')}`);
                            throw new Error(
                                `Texture "${tex.name}" has invalid storage format "${normalizedFormat}". ` +
                                `Valid formats for write access: ${validWriteStorageFormats.join(', ')}`
                            );
                        }

                        bindingMap.set(tex.binding, {
                            binding: tex.binding,
                            visibility: GPUShaderStage.COMPUTE,
                            storageTexture: {
                                format: normalizedFormat,
                                access: 'write-only'
                            }
                        });
                    } else {
                        bindingMap.set(tex.binding, {
                            binding: tex.binding,
                            visibility: GPUShaderStage.COMPUTE,
                            texture: { sampleType: 'float' }
                        });
                    }
                });

                // CRITICAL: Sort entries by binding number
                const bindGroupLayoutEntries = Array.from(bindingMap.values())
                    .sort((a, b) => a.binding - b.binding);

                console.log(`  ğŸ“‹ BindGroupLayout entries (${bindGroupLayoutEntries.length} total):`,
                    bindGroupLayoutEntries.map(e => {
                        let desc = `binding ${e.binding}`;
                        if (e.sampler) desc += ' (sampler)';
                        if (e.buffer) desc += ' (uniform buffer)';
                        if (e.texture) desc += ' (sampled texture)';
                        if (e.storageTexture) desc += ` (storage texture: ${e.storageTexture.format})`;
                        return desc;
                    }).join(', '));

                this.device.pushErrorScope('validation');

                const bindGroupLayout = this.device.createBindGroupLayout({
                    entries: bindGroupLayoutEntries,
                    label: `Pass ${module.passIndex} Bind Group Layout`
                });

                const layoutError = await this.device.popErrorScope();
                if (layoutError) {
                    console.error(`âŒ BindGroupLayout å»ºç«‹éŒ¯èª¤:`, layoutError.message);
                    throw layoutError;
                }

                console.log(`  âœ… BindGroupLayout å»ºç«‹æˆåŠŸ`);

                // 3. Create GPUPipelineLayout
                this.device.pushErrorScope('validation');

                const pipelineLayout = this.device.createPipelineLayout({
                    bindGroupLayouts: [bindGroupLayout],
                    label: `Pass ${module.passIndex} Pipeline Layout`
                });

                const pipelineLayoutError = await this.device.popErrorScope();
                if (pipelineLayoutError) {
                    console.error(`âŒ PipelineLayout å»ºç«‹éŒ¯èª¤:`, pipelineLayoutError.message);
                    throw pipelineLayoutError;
                }

                console.log(`  âœ… PipelineLayout å»ºç«‹æˆåŠŸ`);

                // 4. Create GPUComputePipeline
                this.device.pushErrorScope('validation');

                const computePipeline = await this.device.createComputePipelineAsync({
                    layout: pipelineLayout,
                    compute: {
                        module: shaderModule,
                        entryPoint: 'main_cs',
                    },
                    label: `Pass ${module.passIndex} Compute Pipeline`
                });

                const pipelineError = await this.device.popErrorScope();
                if (pipelineError) {
                    console.error(`âŒ ComputePipeline å»ºç«‹éŒ¯èª¤:`, pipelineError.message);
                    throw pipelineError;
                }

                // Force error processing
                await this.device.queue.submit([]);

                console.log(`  âœ… Pass ${module.passIndex} ç®¡ç·šå»ºç«‹å®Œå…¨æˆåŠŸ`);

                // Store pipeline components
                this.pipelines.set(module.passIndex, {
                    shaderModule,
                    bindGroupLayout,
                    pipelineLayout,
                    computePipeline,
                    resources: module.resources,
                    passInfo: pass
                });

            } catch (error) {
                console.error(`âŒ Pass ${module.passIndex} ç®¡ç·šå»ºç«‹å¤±æ•—:`, error);

                // Output full WGSL code for debugging
                console.group(`ğŸ” Pass ${module.passIndex} å®Œæ•´ WGSL ç¨‹å¼ç¢¼:`);
                const lines = module.wgslCode.split('\n');
                lines.forEach((line, idx) => {
                    console.log(`${(idx + 1).toString().padStart(4)}: ${line}`);
                });
                console.groupEnd();

                throw error;
            }
        }

        console.log(`âœ… å…±æˆåŠŸå»ºç«‹ ${this.pipelines.size} å€‹ç®¡ç·š`);
    }

    /**
     * - EN: Encodes commands to dispatch a specific compute pass.
     * - TW: ç·¨ç¢¼èª¿åº¦ç‰¹å®šè¨ˆç®—é€šé“çš„å‘½ä»¤ã€‚
     */
    dispatchPass(passInfo, commandEncoder) {
        const storedPipeline = this.pipelines.get(passInfo.index);
        if (!storedPipeline) {
            throw new Error(`æ‰¾ä¸åˆ°é€šé“ ${passInfo.index} çš„ç®¡ç·šã€‚æ˜¯å¦å·²ç·¨è­¯?`);
        }

        const {computePipeline, bindGroupLayout, resources, passInfo: originalPassInfo} = storedPipeline;

        // Build bind group entries
        const bindingMap = new Map();

        // Samplers
        resources.samplers.forEach(samp => {
            const sampler = this.resourceManager.getSampler(samp.name);
            if (!sampler) {
                if (samp.name === 'sam') {
                    const defaultSampler = this.device.createSampler({
                        magFilter: 'linear',
                        minFilter: 'linear',
                    });
                    bindingMap.set(samp.binding, {
                        binding: samp.binding,
                        resource: defaultSampler
                    });
                } else {
                    throw new Error(`Sampler ${samp.name} not found in ResourceManager.`);
                }
            } else {
                bindingMap.set(samp.binding, {
                    binding: samp.binding,
                    resource: sampler
                });
            }
        });

        // Uniforms
        if (resources.parameters.length > 0) {
            const uniformBuffer = this.resourceManager.getUniformBuffer();
            if (!uniformBuffer) {
                throw new Error("Uniform buffer not found in ResourceManager.");
            }
            bindingMap.set(1, {
                binding: 1,
                resource: { buffer: uniformBuffer }
            });
        }

        // Textures
        resources.textures.forEach(tex => {
            const texture = this.resourceManager.getTexture(tex.name);
            if (!texture) {
                throw new Error(`Texture ${tex.name} not found in ResourceManager.`);
            }
            bindingMap.set(tex.binding, {
                binding: tex.binding,
                resource: texture.createView()
            });
        });

        // Sort entries by binding number
        const bindGroupEntries = Array.from(bindingMap.values())
            .sort((a, b) => a.binding - b.binding);

        const bindGroup = this.device.createBindGroup({
            layout: bindGroupLayout,
            entries: bindGroupEntries,
            label: `Pass ${passInfo.index} Bind Group`
        });

        // Encode compute pass
        const passEncoder = commandEncoder.beginComputePass();
        passEncoder.setPipeline(computePipeline);
        passEncoder.setBindGroup(0, bindGroup);

        // Calculate workgroup dispatch
        const outputTextureName = originalPassInfo.out[0];
        const outputTexture = this.resourceManager.getTexture(outputTextureName);
        const workgroupSize = originalPassInfo.numThreads;

        const dispatchX = Math.ceil(outputTexture.width / workgroupSize[0]);
        const dispatchY = Math.ceil(outputTexture.height / workgroupSize[1]);

        passEncoder.dispatchWorkgroups(dispatchX, dispatchY, 1);
        passEncoder.end();
    }

    dispose() {
        this.pipelines.clear();
        console.log("PipelineManager: All pipeline states cleared.");
    }
}

// src/runtime/WGSLCodeGenerator.js
/**
 * - EN: Assembles a complete WGSL shader module from WGFX IR objects.
 * - TW: å¾ WGFX IR ç‰©ä»¶çµ„è£å®Œæ•´çš„ WGSL è‘—è‰²å™¨æ¨¡çµ„ã€‚
 */

class WGSLCodeGenerator {
    constructor() {}

    /**
     * - EN: Determines if a texture format is valid for Storage Texture write access
     * - TW: åˆ¤æ–·ç´‹ç†æ ¼å¼æ˜¯å¦æœ‰æ•ˆå¯ç”¨æ–¼ Storage Texture å¯«å…¥å­˜å–
     */
    _isValidStorageFormat(format) {
        const validStorageFormats = [
            'r32float', 'r32sint', 'r32uint',
            'rgba16float', 'rgba16sint', 'rgba16uint',
            'rgba32float', 'rgba32sint', 'rgba32uint',
            'rg32float', 'rg32sint', 'rg32uint'
        ];
        return validStorageFormats.includes(format.toLowerCase().replace(/_/g, ''));
    }

    /**
     * - EN: Upgrades texture format to a storage-compatible format
     * - TW: å°‡ç´‹ç†æ ¼å¼å‡ç´šç‚ºç›¸å®¹æ–¼ Storage çš„æ ¼å¼
     */
    _upgradeToStorageFormat(format) {
        const normalizedFormat = format.toLowerCase().replace(/_/g, '');

        // 8-bit formats must be upgraded to rgba16float for storage use
        if (normalizedFormat === 'rgba8unorm' || normalizedFormat === 'bgra8unorm') {
            return 'rgba16float';
        }

        // 16-bit formats are already valid
        if (normalizedFormat.includes('rgba16') || normalizedFormat.includes('r16')) {
            return normalizedFormat;
        }

        // 32-bit formats are already valid
        if (normalizedFormat.includes('32')) {
            return normalizedFormat;
        }

        // Default fallback: upgrade to rgba16float
        console.warn(`Unknown format "${format}" upgraded to rgba16float for storage texture compatibility`);
        return 'rgba16float';
    }

    /**
     * - EN: Preprocesses pass code to fix WGSL type errors and syntax issues.
     * - TW: é è™•ç†é€šé“ç¨‹å¼ç¢¼ä»¥ä¿®æ­£ WGSL å‹åˆ¥éŒ¯èª¤å’Œèªæ³•å•é¡Œã€‚
     */
    _preprocessPassCode(passCode, passIndex) {
        let processedCode = passCode;

        // Fix WGSL type error: vec2<u32> + f32
        processedCode = processedCode.replace(/\(gxy \+ 0\.5f\)/g, '(MF2(gxy) + 0.5f)');

        // Replace threadId.x with local_id.x
        processedCode = processedCode.replace(/threadId\.x/g, 'local_id.x');

        // Apply gxy fixes based on passIndex
        if (passIndex === 1) {
            processedCode = processedCode.replace(
                /let gxy = \(Rmp8x8\(local_id\.x\) << 1u\) \+ workgroup_id\.xy;/,
                'let gxy = (Rmp8x8(local_id.x) * 2u) + workgroup_id.xy;'
            );
        } else if (passIndex >= 2 && passIndex <= 7) {
            processedCode = processedCode.replace(
                /let gxy: uint2\s*=\s*Rmp8x8\(local_id\.x\) \+ blockStart;/,
                'let gxy: uint2 = Rmp8x8(local_id.x) + workgroup_id.xy * 8u;'
            );
        } else if (passIndex === 8) {
            processedCode = processedCode.replace(
                /let gxy: uint2 = Rmp8x8\(local_id\.x\) \+ workgroup_id\.xy;/,
                'let gxy: uint2 = Rmp8x8(local_id.x) + workgroup_id.xy * 8u;'
            );
        }

        // Fix variable redeclarations
        processedCode = processedCode.replace(
            /var\s+(a1|b1|c1|d1|e1|f1|g1|h1|i1|na1|nb1|nc1|nd1|ne1|nf1|ng1|nh1|ni1|na2|nb2|nc2|nd2|ne2|nf2|ng2|nh2|ni2|na3|nb3|nc3|nd3|ne3|nf3|ng3|nh3|ni3)\s+=\s+max\(\1,\s+MF4\(0\.0\)\);/g,
            '$1 = max($1, MF4(0.0));'
        );

        return processedCode;
    }

    /**
     * - EN: Assembles final WGSL shader modules from parsed shader information (IR).
     * - TW: å¾è§£æå¾Œçš„è‘—è‰²å™¨è³‡è¨Š (IR) çµ„è£æœ€çµ‚çš„ WGSL è‘—è‰²å™¨æ¨¡çµ„ã€‚
     */
    generate(shaderInfo) {
        const generatedModules = [];

        // Inject common code block
        const commonCode = shaderInfo.commonCode
            ? `// --- é€šç”¨ç¨‹å¼ç¢¼ ---\n${shaderInfo.commonCode}\n\n`
            : '';

        // Generate uniform buffer structure if parameters exist
        let uniformBufferCode = '';
        if (shaderInfo.parameters.length > 0) {
            uniformBufferCode += `struct Uniforms {\n`;
            shaderInfo.parameters.forEach(p => {
                const type = p.type === 'int' ? 'i32' : 'f32';
                uniformBufferCode += `    ${p.name}: ${type},\n`;
            });
            uniformBufferCode += `};\n`;
            uniformBufferCode += `@group(0) @binding(1) var<uniform> uniforms: Uniforms;\n\n`;
        }

        // Process each pass
        shaderInfo.passes.forEach(pass => {
            let wgsl = `// ç”± WGFX çµ„è£å™¨ç”Ÿæˆ - æ™‚é–“æˆ³è¨˜: ${Date.now()} - Pass ${pass.index}\n\n`;
            wgsl += commonCode;

            // Declare default sampler
            wgsl += `@group(0) @binding(0) var sam: sampler;\n\n`;
            wgsl += uniformBufferCode;

            // Initialize resource tracking
            const passResources = {
                textures: [],
                samplers: [],
                parameters: shaderInfo.parameters
            };

            // Add default sampler
            passResources.samplers.push({
                name: 'sam',
                binding: 0,
                group: 0,
                filter: 'LINEAR'
            });

            // Collect textures and samplers used by this pass
            const usedTextureNames = new Set([...pass.in, ...pass.out]);

            // Add globally declared samplers
            shaderInfo.samplers.forEach(resource => {
                if (resource.name !== 'sam' && !passResources.samplers.some(s => s.name === resource.name)) {
                    passResources.samplers.push(resource);
                }
            });

            // Allocate bindings (sam:0, uniforms:1 if exists, then textures/samplers from 2 or 1)
            let bindingIndex = (shaderInfo.parameters.length > 0) ? 2 : 1;

            // Process textures
            shaderInfo.textures.forEach(tex => {
                // Check if this texture is used by this pass
                const isUsed = [...usedTextureNames].some(usedName =>
                    tex.name === usedName || tex.name.startsWith(usedName + "_")
                );

                if (!isUsed) return;

                // Determine texture usage (Sampled vs Storage)
                const isOutputInThisPass = pass.out.includes(tex.name);
                let isStorage = false;

                if (tex.name === 'OUTPUT') {
                    isStorage = true;
                } else if (tex.name === 'INPUT') {
                    isStorage = false; // INPUT is always read-only (Sampled)
                } else if (isOutputInThisPass) {
                    isStorage = true; // Output textures must be Storage
                } else {
                    isStorage = false; // Other cases (inputs) are Sampled
                }

                // Process format and compatibility
                let format = (tex.format || 'rgba8unorm').toLowerCase().replace(/_/g, '');

                // CRITICAL FIX: Upgrade format for storage textures
                if (isStorage) {
                    const originalFormat = format;
                    format = this._upgradeToStorageFormat(format);

                    if (originalFormat !== format) {
                        console.log(`Pass ${pass.index}: Upgraded texture "${tex.name}" format from ${originalFormat} to ${format} for storage compatibility`);
                    }

                    // Double-check format validity
                    if (!this._isValidStorageFormat(format)) {
                        console.error(`Pass ${pass.index}: Invalid storage format "${format}" for texture "${tex.name}"`);
                        throw new Error(`Texture "${tex.name}" has invalid storage format "${format}". Valid formats: r32float, rgba16float, rgba32float, etc.`);
                    }
                }

                // Generate WGSL texture declaration
                let textureType;
                if (isStorage) {
                    textureType = `texture_storage_2d<${format}, write>`;
                } else {
                    textureType = `texture_2d<f32>`;
                }

                const currentBinding = bindingIndex++;
                wgsl += `@group(0) @binding(${currentBinding}) var ${tex.name}: ${textureType};\n`;

                // Store resource info with corrected format
                passResources.textures.push({
                    ...tex,
                    format: format, // Use corrected format
                    binding: currentBinding,
                    group: 0,
                    isStorage: isStorage
                });
            });

            // Declare additional samplers (excluding 'sam')
            shaderInfo.samplers.forEach(samp => {
                if (samp.name !== 'sam') {
                    const currentBinding = bindingIndex++;
                    wgsl += `@group(0) @binding(${currentBinding}) var ${samp.name}: sampler;\n`;
                    passResources.samplers.push({
                        ...samp,
                        binding: currentBinding,
                        group: 0
                    });
                }
            });
            wgsl += '\n';

            // Append pass code
            wgsl += `// --- é€šé“ ${pass.index} ---\n`;

            // Remove //! directives and preprocess
            let processedPassCode = pass.code.replace(/\/\/!.*\n/g, '');
            processedPassCode = this._preprocessPassCode(processedPassCode, pass.index);

            // Set workgroup size
            const numThreads = pass.numThreads || [1, 1, 1];

            // Remove existing @compute or @workgroup_size attributes
            processedPassCode = processedPassCode.replace(/@compute\s*@workgroup_size\([^)]+\)\s*/g, '');

            // Standardize entry point name
            const passFunctionSignatureRegex = new RegExp(`fn Pass${pass.index}`);
            processedPassCode = processedPassCode.replace(
                passFunctionSignatureRegex,
                `fn main_cs `
            );

            // Prepend attributes
            processedPassCode = `@compute @workgroup_size(${numThreads[0]}, ${numThreads[1]}, ${numThreads[2]}) ${processedPassCode}`;

            wgsl += processedPassCode;

            // Store generated module
            generatedModules.push({
                wgslCode: wgsl.replace(/\r\n/g, '\n'),
                passIndex: pass.index,
                resources: passResources
            });
        });

        return generatedModules;
    }
}

// src/runtime/UniformBinder.js

/**
 * @fileoverview
 * - EN: Handles dynamic updates of uniform buffers.
 *   This class provides a simple API for changing uniform values at runtime.
 * - TW: è™•ç†çµ±ä¸€ç·©è¡å€çš„å‹•æ…‹æ›´æ–°ã€‚
 *   æ­¤é¡åˆ¥æä¾›ä¸€å€‹ç°¡å–®çš„ APIï¼Œç”¨æ–¼åœ¨é‹è¡Œæ™‚æ›´æ”¹çµ±ä¸€å€¼ã€‚
 */

let GPUDevice;

/**
 * - EN: In a Node.js environment, native WebGPU objects don't exist.
 *   We check for their existence on the global scope. If they don't exist,
 *   `GPUDevice` will remain `undefined`, which is safe for the CLI code path
 *   as it doesn't instantiate or use any GPU-related objects.
 * - TW: åœ¨ Node.js ç’°å¢ƒä¸­ï¼ŒåŸç”Ÿ WebGPU ç‰©ä»¶ä¸å­˜åœ¨ã€‚
 *   æˆ‘å€‘æª¢æŸ¥å®ƒå€‘æ˜¯å¦åœ¨å…¨åŸŸç¯„åœå…§å­˜åœ¨ã€‚å¦‚æœä¸å­˜åœ¨ï¼Œ
 *   `GPUDevice` å°‡ä¿æŒ `undefined`ï¼Œé€™å°æ–¼ CLI ç¨‹å¼ç¢¼è·¯å¾‘æ˜¯å®‰å…¨çš„ï¼Œ
 *   å› ç‚ºå®ƒä¸å¯¦ä¾‹åŒ–æˆ–ä½¿ç”¨ä»»ä½•èˆ‡ GPU ç›¸é—œçš„ç‰©ä»¶ã€‚
 */
try {
    /**
     * - EN: This will only succeed in a browser-like environment with WebGPU support.
     * - TW: é€™åªæœƒåœ¨æ”¯æ´ WebGPU çš„ç€è¦½å™¨ç’°å¢ƒä¸­æˆåŠŸã€‚
     */
    if (globalThis.GPUDevice) {
        GPUDevice = globalThis.GPUDevice;
    }
    /**
     * - EN: In Node.js or a non-WebGPU environment, this will remain undefined.
     * - TW: åœ¨ Node.js æˆ–é WebGPU ç’°å¢ƒä¸­ï¼Œé€™å°‡ä¿æŒæœªå®šç¾©ã€‚
     */
} catch (e) {
    /**
     * - EN: Ignore any errors during this detection phase.
     * - TW: åœ¨æ­¤æª¢æ¸¬éšæ®µå¿½ç•¥ä»»ä½•éŒ¯èª¤ã€‚
     */
}


class UniformBinder {
    /**
     * @param {GPUDevice} [device]
     * - EN: The active WebGPU device.
     * - TW: ä½œç”¨ä¸­çš„ WebGPU è£ç½®ã€‚
     * @param {import('./ResourceManager.js').ResourceManager} resourceManager
     * - EN: An instance of the resource manager.
     * - TW: è³‡æºç®¡ç†å™¨çš„å¯¦ä¾‹ã€‚
     */
    constructor(device, resourceManager) {
        this.device = device || new GPUDevice();
        /**
         * - EN: Use provided device or a mock device.
         * - TW: ä½¿ç”¨æä¾›çš„è£ç½®æˆ–æ¨¡æ“¬è£ç½®ã€‚
         */
        this.resourceManager = resourceManager;
    }

    /**
     * - EN: Dynamically updates the value of a single uniform in the shared uniform buffer.
     * - TW: åœ¨å…±äº«çµ±ä¸€ç·©è¡å€ä¸­å‹•æ…‹æ›´æ–°å–®å€‹çµ±ä¸€çš„å€¼ã€‚
     * @param {string} name
     * - EN: The name of the uniform to update (e.g., `Strength`).
     * - TW: è¦æ›´æ–°çš„çµ±ä¸€åç¨± (ä¾‹å¦‚ï¼š`Strength`)ã€‚
     * @param {number} value
     * - EN: The new numeric value for the uniform.
     * - TW: çµ±ä¸€çš„æ–°æ•¸å€¼ã€‚
     */
    updateUniform(name, value) {
        /**
         * - EN: Retrieve uniform metadata (buffer, offset, size) from the resource manager.
         * - TW: å¾è³‡æºç®¡ç†å™¨ç²å–çµ±ä¸€çš„å…ƒè³‡æ–™ (ç·©è¡å€ã€åç§»é‡ã€å¤§å°)ã€‚
         */
        const uniformInfo = this.resourceManager.getUniform(name);
        if (!uniformInfo) {
            console.warn(`Uniform '${name}' not found. Cannot update. / æ‰¾ä¸åˆ°çµ±ä¸€ '${name}'ã€‚ç„¡æ³•æ›´æ–°ã€‚`);
            return;
        }

        const {buffer, offset, size} = uniformInfo;

        /**
         * - EN: Create a temporary typed array with the new value.
         *   This implementation simplifies things, assuming all uniforms are 4-byte floats.
         *   A more robust solution would check the parameter type from the IR.
         * - TW: ä½¿ç”¨æ–°å€¼å»ºç«‹ä¸€å€‹è‡¨æ™‚çš„é¡å‹åŒ–é™£åˆ—ã€‚
         *   æ­¤å¯¦ä½œç°¡åŒ–äº†äº‹æƒ…ï¼Œå‡è¨­æ‰€æœ‰çµ±ä¸€éƒ½æ˜¯ 4 ä½å…ƒçµ„æµ®é»æ•¸ã€‚
         *   æ›´ç©©å¥çš„è§£æ±ºæ–¹æ¡ˆå°‡æª¢æŸ¥ IR ä¸­çš„åƒæ•¸é¡å‹ã€‚
         */
        const data = new Float32Array([value]);

        if (data.byteLength > size) {
            console.error(`Data size mismatch for uniform '${name}'. Expected ${size}, but got ${data.byteLength}. / çµ±ä¸€ '${name}' çš„è³‡æ–™å¤§å°ä¸åŒ¹é…ã€‚é æœŸç‚º ${size}ï¼Œä½†å¾—åˆ° ${data.byteLength}ã€‚`);
            return;
        }

        /**
         * - EN: Write the data to the correct position in the GPU buffer.
         * - TW: å°‡è³‡æ–™å¯«å…¥ GPU ç·©è¡å€ä¸­çš„æ­£ç¢ºä½ç½®ã€‚
         */
        this.device.queue.writeBuffer(
            buffer,
            /**
             * - EN: Destination buffer.
             * - TW: ç›®æ¨™ç·©è¡å€ã€‚
             */
            offset,
            /**
             * - EN: Byte offset to start writing from.
             * - TW: é–‹å§‹å¯«å…¥çš„ä½å…ƒçµ„åç§»é‡ã€‚
             */
            data,
            /**
             * - EN: Source data.
             * - TW: ä¾†æºè³‡æ–™ã€‚
             */
            0,
            /**
             * - EN: Offset within the source data.
             * - TW: ä¾†æºè³‡æ–™ä¸­çš„åç§»é‡ã€‚
             */
            size
            /**
             * - EN: Number of bytes to write.
             * - TW: è¦å¯«å…¥çš„ä½å…ƒçµ„æ•¸ã€‚
             */
        );
    }
}

// src/runtime/WGFXRuntime.js


class WGFXRuntime {
    /**
     * @param {GPUDevice} device
     * - EN: The active WebGPU device.
     * - TW: ä½œç”¨ä¸­çš„ WebGPU è£ç½®ã€‚
     */
    constructor(device) {
        if (!device) {
            /**
             * - EN: WGFXRuntime requires a valid WebGPU device. No device provided.
             * - TW: WGFXRuntime éœ€è¦ä¸€å€‹æœ‰æ•ˆçš„ WebGPU è£ç½®ã€‚æœªæä¾›è£ç½®ã€‚
             */
            throw new Error("WGFXRuntime requires a valid WebGPU device. No device provided.");
        }
        this.device = device;

        /**
         * - EN: Instantiate all necessary sub-modules.
         * - TW: å¯¦ä¾‹åŒ–æ‰€æœ‰å¿…è¦çš„å­æ¨¡çµ„ã€‚
         */
        // this.parser = new ShaderParser(); // No longer needed
        this.resourceManager = new ResourceManager(this.device);
        this.pipelineManager = new PipelineManager(this.device, this.resourceManager);
        this.wgslCodeGenerator = new WGSLCodeGenerator();
        this.uniformBinder = new UniformBinder(this.device, this.resourceManager);

        /**
         * - EN: Intermediate representation of the currently compiled shader.
         * - TW: ç•¶å‰ç·¨è­¯è‘—è‰²å™¨çš„ä¸­ä»‹è¡¨ç¤ºã€‚
         * @type {import('./ShaderParser.js').WGFXShaderInfo | null}
         */
        this.shaderInfo = null;
    }

    /**
     * - EN: Compiles a WGFX effect from a code string. This is the main entry point for setting up a new effect.
     *   The process involves parsing, code generation, resource allocation, and pipeline creation.
     * - TW: å¾ç¨‹å¼ç¢¼å­—ä¸²ç·¨è­¯ WGFX æ•ˆæœã€‚é€™æ˜¯è¨­å®šæ–°æ•ˆæœçš„ä¸»è¦å…¥å£é»ã€‚
     *   è©²éç¨‹æ¶‰åŠè§£æã€ç¨‹å¼ç¢¼ç”Ÿæˆã€è³‡æºåˆ†é…å’Œç®¡ç·šå»ºç«‹ã€‚
     * @param {string} effectCode
     * - EN: The string containing the entire WGFX effect code.
     * - TW: åŒ…å«æ•´å€‹ WGFX æ•ˆæœç¨‹å¼ç¢¼çš„å­—ä¸²ã€‚
     * @returns {Promise<void>}
     * - EN: A Promise that resolves when compilation is complete.
     * - TW: ç·¨è­¯å®Œæˆæ™‚è§£æçš„ Promiseã€‚
     */
    async compile(effectCode, externalResources = {}) {
        // FIXME: This is a temporary solution to pass external resources.
        // A more robust solution would be to have a dedicated method to set resources.
        /**
         * - EN: Starting effect compilation.
         * - TW: é–‹å§‹æ•ˆæœç·¨è­¯ã€‚
         */
        console.log("WGFXRuntime: Starting effect compilation.");
        /**
         * - EN: 1. Parse the FX file to get the Intermediate Representation (IR).
         * - TW: 1. è§£æ FX æª”æ¡ˆä»¥ç²å–ä¸­ä»‹è¡¨ç¤º (IR)ã€‚
         */
        this.shaderInfo = peg$parse(effectCode);
        /**
         * - EN: ShaderInfo (IR) parsed.
         * - TW: å·²è§£æ ShaderInfo (IR)ã€‚
         */
        console.log("WGFXRuntime: ShaderInfo (IR) parsed:", this.shaderInfo);
        /**
         * - EN: 2. Generate a single WGSL shader module from the IR.
         * - TW: 2. å¾ IR ç”Ÿæˆå–®å€‹ WGSL è‘—è‰²å™¨æ¨¡çµ„ã€‚
         */
        const generatedModules = this.wgslCodeGenerator.generate(this.shaderInfo);
        // if (this.parser.debug) {
        //     /**
        //      * - EN: Old debug check removed
        //      * - TW: èˆŠçš„èª¿è©¦æª¢æŸ¥å·²ç§»é™¤
        //      */
        //     console.log("WGFXRuntime: Generated WGSL module:", generatedModules);
        // }

        /**
         * - EN: 3. Initialize all GPU resources (textures, samplers, buffers) based on the IR.
         * - TW: 3. æ ¹æ“š IR åˆå§‹åŒ–æ‰€æœ‰ GPU è³‡æº (ç´‹ç†ã€å–æ¨£å™¨ã€ç·©è¡å€)ã€‚
         */
        this.resourceManager.initialize(this.shaderInfo, externalResources);
        /**
         * - EN: Resources initialized.
         * - TW: è³‡æºå·²åˆå§‹åŒ–ã€‚
         */
        console.log("WGFXRuntime: Resources initialized.");
        /**
         * - EN: 4. Create compute pipelines for each pass.
         * - TW: 4. ç‚ºæ¯å€‹é€šé“å»ºç«‹è¨ˆç®—ç®¡ç·šã€‚
         */
        await this.pipelineManager.createPipelines(this.shaderInfo, generatedModules);
        /**
         * - EN: Pipelines created.
         * - TW: ç®¡ç·šå·²å»ºç«‹ã€‚
         */
        console.log("WGFXRuntime: Pipelines created.");
        /**
         * - EN: Compilation complete.
         * - TW: ç·¨è­¯å®Œæˆã€‚
         */
        console.log("WGFXRuntime: Compilation complete.");
    }

    /**
     * - EN: Encodes commands to dispatch a specific compute pass.
     * - TW: ç·¨ç¢¼èª¿åº¦ç‰¹å®šè¨ˆç®—é€šé“çš„å‘½ä»¤ã€‚
     * @param {string} passName
     * - EN: The name of the pass to dispatch (e.g., `PASS_1`).
     * - TW: è¦èª¿åº¦çš„é€šé“åç¨± (ä¾‹å¦‚ï¼š`PASS_1`)ã€‚
     * @param {GPUCommandEncoder} commandEncoder
     * - EN: The command encoder for the current frame.
     * - TW: ç•¶å‰å¹€çš„å‘½ä»¤ç·¨ç¢¼å™¨ã€‚
     */
    dispatchPass(passName, commandEncoder) {
        if (!this.shaderInfo) {
            /**
             * - EN: Effect not compiled. Call compile() first.
             * - TW: æ•ˆæœæœªç·¨è­¯ã€‚è«‹å…ˆå‘¼å« compile()ã€‚
             */
            throw new Error("Effect not compiled. Call compile() first.");
        }

        /**
         * - EN: Look up the corresponding pass information from the IR.
         * - TW: å¾ IR ä¸­æŸ¥æ‰¾å°æ‡‰çš„é€šé“è³‡è¨Šã€‚
         */
        const passIndex = parseInt(passName.split('_')[1], 10);
        const passInfo = this.shaderInfo.passes.find(p => p.index === passIndex);
        if (!passInfo) {
            /**
             * - EN: Pass `passName` not found in shader information.
             * - TW: åœ¨è‘—è‰²å™¨è³‡è¨Šä¸­æ‰¾ä¸åˆ°é€šé“ `passName`ã€‚
             */
            throw new Error(`Pass "${passName}" not found in shader information.`);
        }

        /**
         * - EN: Delegate the actual dispatch logic to the pipeline manager.
         * - TW: å°‡å¯¦éš›çš„èª¿åº¦é‚è¼¯å§”è¨—çµ¦ç®¡ç·šç®¡ç†å™¨ã€‚
         */
        this.pipelineManager.dispatchPass(passInfo, commandEncoder);
    }

    /**
     * - EN: Updates the value of a uniform parameter in the GPU buffer.
     * - TW: æ›´æ–° GPU ç·©è¡å€ä¸­ uniform åƒæ•¸çš„å€¼ã€‚
     * @param {string} name
     * - EN: The name of the uniform to update.
     * - TW: è¦æ›´æ–°çš„ uniform åç¨±ã€‚
     * @param {number} value
     * - EN: The new value for the uniform.
     * - TW: uniform çš„æ–°å€¼ã€‚
     */
    updateUniform(name, value) {
        if (!this.shaderInfo) {
            /**
             * - EN: Effect not compiled. Call compile() first.
             * - TW: æ•ˆæœæœªç·¨è­¯ã€‚è«‹å…ˆå‘¼å« compile()ã€‚
             */
            throw new Error("Effect not compiled. Call compile() first.");
        }
        this.uniformBinder.updateUniform(name, value);
    }

    /**
     * - EN: Gets the GPUTextureView of the final output texture, usually named 'OUTPUT'.
     * - TW: ç²å–æœ€çµ‚è¼¸å‡ºç´‹ç†çš„ GPUTextureViewï¼Œé€šå¸¸å‘½åç‚º 'OUTPUT'ã€‚
     * @returns {GPUTextureView}
     * - EN: The texture view of the final output.
     * - TW: æœ€çµ‚è¼¸å‡ºçš„ç´‹ç†è¦–åœ–ã€‚
     */
    getOutput() {
        const outputTexture = this.resourceManager.getTexture('OUTPUT');
        if (!outputTexture) {
            /**
             * - EN: Output texture `OUTPUT` not found in ResourceManager. Ensure it is correctly defined or managed.
             * - TW: åœ¨ ResourceManager ä¸­æ‰¾ä¸åˆ°è¼¸å‡ºç´‹ç† `OUTPUT`ã€‚è«‹ç¢ºä¿å·²æ­£ç¢ºå®šç¾©æˆ–ç®¡ç†ã€‚
             */
            throw new Error("Output texture 'OUTPUT' not found in ResourceManager. Ensure it is correctly defined or managed.");
        }
        return outputTexture.createView();
    }

    /**
     * - EN: Utility function to get raw GPU resources.
     * - TW: ç²å–åŸå§‹ GPU è³‡æºçš„å¯¦ç”¨å‡½æ•¸ã€‚
     * @param {string} name
     * - EN: The name of the resource.
     * - TW: è³‡æºçš„åç¨±ã€‚
     * @returns {GPUTexture | GPUSampler | GPUBuffer | undefined}
     * - EN: The underlying GPU resource.
     * - TW: åº•å±¤ GPU è³‡æºã€‚
     */
    getResource(name) {
        return this.resourceManager.getTexture(name)
            || this.resourceManager.getSampler(name)
            || this.resourceManager.getUniform(name)?.buffer;
    }
}

// src/index.js


/**
 * - EN: Singleton instance of WGFXRuntime.
 * - TW: WGFXRuntime çš„å–®ä¾‹å¯¦ä¾‹ã€‚
 * @type {WGFXRuntime | null}
 */
let runtimeInstance = null;

/**
 * - EN: Initializes the runtime (if needed) and compiles the WGFX effect.
 *   This function must be called before any other API functions.
 * - TW: åˆå§‹åŒ–é‹è¡Œæ™‚ (å¦‚æœéœ€è¦) ä¸¦ç·¨è­¯ WGFX æ•ˆæœã€‚
 *   å¿…é ˆåœ¨ä»»ä½•å…¶ä»– API å‡½æ•¸ä¹‹å‰å‘¼å«æ­¤å‡½æ•¸ã€‚
 * @param {string} effectCode
 * - EN: The string containing the entire WGFX effect code.
 * - TW: åŒ…å«æ•´å€‹ WGFX æ•ˆæœç¨‹å¼ç¢¼çš„å­—ä¸²ã€‚
 * @param {GPUDevice} device
 * - EN: The active WebGPU device.
 * - TW: ä½œç”¨ä¸­çš„ WebGPU è£ç½®ã€‚
 * @returns {Promise<void>}
 * - EN: A Promise that resolves when compilation is complete.
 * - TW: ç·¨è­¯å®Œæˆæ™‚è§£æçš„ Promiseã€‚
 */
async function compile(effectCode, device, externalResources = {}) {
    runtimeInstance = new WGFXRuntime(device);
    await runtimeInstance.compile(effectCode, externalResources);
    return runtimeInstance.shaderInfo;
}

/**
 * - EN: Encodes commands to dispatch a specific compute pass in the compiled effect.
 * - TW: ç·¨ç¢¼èª¿åº¦å·²ç·¨è­¯æ•ˆæœä¸­ç‰¹å®šè¨ˆç®—é€šé“çš„å‘½ä»¤ã€‚
 * @param {string} passName
 * - EN: The name of the pass to dispatch (e.g., 'PASS_1').
 * - TW: è¦èª¿åº¦çš„é€šé“åç¨± (ä¾‹å¦‚ï¼š'PASS_1')ã€‚
 * @param {GPUCommandEncoder} commandEncoder
 * - EN: The command encoder for the current frame.
 * - TW: ç•¶å‰å¹€çš„å‘½ä»¤ç·¨ç¢¼å™¨ã€‚
 */
function dispatchPass(passName, commandEncoder) {
    if (!runtimeInstance) {
        throw new Error("WGFX runtime not initialized. Call compile() first. / WGFX é‹è¡Œæ™‚æœªåˆå§‹åŒ–ã€‚è«‹å…ˆå‘¼å« compile()ã€‚");
    }
    runtimeInstance.dispatchPass(passName, commandEncoder);
}

/**
 * - EN: Updates the value of a single uniform parameter.
 * - TW: æ›´æ–°å–®å€‹çµ±ä¸€åƒæ•¸çš„å€¼ã€‚
 * @param {string} name
 * - EN: The name of the uniform to update.
 * - TW: è¦æ›´æ–°çš„çµ±ä¸€åç¨±ã€‚
 * @param {number} value
 * - EN: The new numeric value for the uniform.
 * - TW: çµ±ä¸€çš„æ–°æ•¸å€¼ã€‚
 */
function updateUniform(name, value) {
    if (!runtimeInstance) {
        throw new Error("WGFX runtime not initialized. Call compile() first. / WGFX é‹è¡Œæ™‚æœªåˆå§‹åŒ–ã€‚è«‹å…ˆå‘¼å« compile()ã€‚");
    }
    runtimeInstance.updateUniform(name, value);
}

/**
 * - EN: Gets the GPUTextureView of the final output texture.
 *   By convention, this is the texture named 'OUTPUT' in the WGFX file.
 * - TW: ç²å–æœ€çµ‚è¼¸å‡ºç´‹ç†çš„ GPUTextureViewã€‚
 *   æŒ‰ç…§æ…£ä¾‹ï¼Œé€™æ˜¯ WGFX æª”æ¡ˆä¸­åç‚º 'OUTPUT' çš„ç´‹ç†ã€‚
 * @returns {GPUTextureView}
 * - EN: The texture view of the final output.
 * - TW: æœ€çµ‚è¼¸å‡ºçš„ç´‹ç†è¦–åœ–ã€‚
 */
function getOutput() {
    if (!runtimeInstance) {
        throw new Error("WGFX runtime not initialized. Call compile() first. / WGFX é‹è¡Œæ™‚æœªåˆå§‹åŒ–ã€‚è«‹å…ˆå‘¼å« compile()ã€‚");
    }
    return runtimeInstance.getOutput();
}

exports.compile = compile;
exports.dispatchPass = dispatchPass;
exports.getOutput = getOutput;
exports.updateUniform = updateUniform;
