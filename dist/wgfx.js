'use strict';

// @generated by Peggy 5.0.6.
//
// https://peggyjs.org/


class peg$SyntaxError extends SyntaxError {
    constructor(message, expected, found, location) {
        super(message);
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";
    }

    static buildMessage(expected, found) {
        function hex(ch) {
            return ch.codePointAt(0).toString(16).toUpperCase();
        }

        const nonPrintable = Object.prototype.hasOwnProperty.call(RegExp.prototype, "unicode")
            ? new RegExp("[\\p{C}\\p{Mn}\\p{Mc}]", "gu")
            : null;

        function unicodeEscape(s) {
            if (nonPrintable) {
                return s.replace(nonPrintable, ch => "\\u{" + hex(ch) + "}");
            }
            return s;
        }

        function literalEscape(s) {
            return unicodeEscape(s
                .replace(/\\/g, "\\\\")
                .replace(/"/g, "\\\"")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g, ch => "\\x0" + hex(ch))
                .replace(/[\x10-\x1F\x7F-\x9F]/g, ch => "\\x" + hex(ch)));
        }

        function classEscape(s) {
            return unicodeEscape(s
                .replace(/\\/g, "\\\\")
                .replace(/\]/g, "\\]")
                .replace(/\^/g, "\\^")
                .replace(/-/g, "\\-")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g, ch => "\\x0" + hex(ch))
                .replace(/[\x10-\x1F\x7F-\x9F]/g, ch => "\\x" + hex(ch)));
        }

        const DESCRIBE_EXPECTATION_FNS = {
            literal(expectation) {
                return "\"" + literalEscape(expectation.text) + "\"";
            },

            class(expectation) {
                const escapedParts = expectation.parts.map(
                    part => (Array.isArray(part)
                        ? classEscape(part[0]) + "-" + classEscape(part[1])
                        : classEscape(part))
                );

                return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]" + (expectation.unicode ? "u" : "");
            },

            any() {
                return "any character";
            },

            end() {
                return "end of input";
            },

            other(expectation) {
                return expectation.description;
            },
        };

        function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }

        function describeExpected(expected) {
            const descriptions = expected.map(describeExpectation);
            descriptions.sort();

            if (descriptions.length > 0) {
                let j = 1;
                for (let i = 1; i < descriptions.length; i++) {
                    if (descriptions[i - 1] !== descriptions[i]) {
                        descriptions[j] = descriptions[i];
                        j++;
                    }
                }
                descriptions.length = j;
            }

            switch (descriptions.length) {
                case 1:
                    return descriptions[0];

                case 2:
                    return descriptions[0] + " or " + descriptions[1];

                default:
                    return descriptions.slice(0, -1).join(", ")
                        + ", or "
                        + descriptions[descriptions.length - 1];
            }
        }

        function describeFound(found) {
            return found ? "\"" + literalEscape(found) + "\"" : "end of input";
        }

        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    }

    format(sources) {
        let str = "Error: " + this.message;
        if (this.location) {
            let src = null;
            const st = sources.find(s => s.source === this.location.source);
            if (st) {
                src = st.text.split(/\r\n|\n|\r/g);
            }
            const s = this.location.start;
            const offset_s = (this.location.source && (typeof this.location.source.offset === "function"))
                ? this.location.source.offset(s)
                : s;
            const loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
            if (src) {
                const e = this.location.end;
                const filler = "".padEnd(offset_s.line.toString().length, " ");
                const line = src[s.line - 1];
                const last = s.line === e.line ? e.column : line.length + 1;
                const hatLen = (last - s.column) || 1;
                str += "\n --> " + loc + "\n"
                    + filler + " |\n"
                    + offset_s.line + " | " + line + "\n"
                    + filler + " | " + "".padEnd(s.column - 1, " ")
                    + "".padEnd(hatLen, "^");
            } else {
                str += "\n at " + loc;
            }
        }
        return str;
    }
}

function peg$parse(input, options) {
    options = options !== undefined ? options : {};

    const peg$FAILED = {};
    const peg$source = options.grammarSource;

    const peg$startRuleFunctions = {
        start: peg$parsestart,
    };
    let peg$startRuleFunction = peg$parsestart;

    const peg$c0 = "\n";
    const peg$c1 = "//!";

    const peg$r0 = /^[^\n]/;
    const peg$r1 = /^[a-zA-Z0-9_]/;
    const peg$r2 = /^[ \t]/;

    const peg$e0 = peg$literalExpectation("\n", false);
    const peg$e1 = peg$literalExpectation("//!", false);
    const peg$e2 = peg$classExpectation(["\n"], true, false, false);
    const peg$e3 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_"], false, false, false);
    const peg$e4 = peg$classExpectation([" ", "\t"], false, false, false);

    function peg$f0() {
        // Commit the last block if it was a PASS and had accumulated code.
        // 如果最後一個區塊是 PASS 並且有累積的程式碼，則提交它。
        if (currentBlock === 'PASS' && passCodeBuffer.length > 0) {
            currentData.code = passCodeBuffer.join('\n');
        }
        // Commit any remaining current block data.
        // 提交任何剩餘的當前區塊資料。
        if (currentData) commitBlock(currentBlock, currentData);
        return shaderInfo;
    }

    function peg$f1() {
        return {type: "empty"};
    }

    function peg$f2(name, value) {
        const directive = name.toUpperCase();
        const val = value.trim();

        // Handle the 'END' directive, which explicitly closes the current block.
        // 處理 'END' 指令，它會明確關閉當前區塊。
        if (directive === 'END') {
            // If a PASS block was active, commit its accumulated code.
            // 如果 PASS 區塊處於活動狀態，則提交其累積的程式碼。
            if (currentBlock === 'PASS' && passCodeBuffer.length > 0) {
                currentData.code = passCodeBuffer.join('\n');
                passCodeBuffer = [];
            }
            // Commit any remaining current block data before ending.
            // 在結束前提交任何剩餘的當前區塊資料。
            if (currentData) {
                commitBlock(currentBlock, currentData);
            }
            currentBlock = null;
            currentData = null;
            return {type: "directive", directive: "END"};
        }

        // Check for block-starting directives.
        // 檢查區塊起始指令。
        if (["PARAMETER", "TEXTURE", "SAMPLER", "COMMON", "PASS", "VERSION", "SORT_NAME", "USE", "CAPABILITY"].includes(directive)) {
            // If we were in a PASS block, commit its code first before starting a new block.
            // 如果我們在 PASS 區塊中，則在開始新區塊之前先提交其程式碼。
            if (currentBlock === 'PASS' && passCodeBuffer.length > 0) {
                currentData.code = passCodeBuffer.join('\n');
                passCodeBuffer = [];
            }
            // Commit the data of the previous block.
            // 提交前一個區塊的資料。
            if (currentData) {
                commitBlock(currentBlock, currentData);
            }

            // Start a new block based on the directive.
            // 根據指令開始一個新區塊。
            if (["PARAMETER", "TEXTURE", "SAMPLER", "COMMON", "PASS"].includes(directive)) {
                currentBlock = directive;
                currentData = {id: val, lines: []}; // Initialize currentData for the new block.
                if (directive === 'PASS') currentData.index = parseInt(val, 10); // Special handling for PASS index.
            } else { // Global directives (VERSION, SORT_NAME, USE, CAPABILITY) are self-contained and don't start a multi-line block.
                currentBlock = null;
                currentData = null;
                commitBlock(directive, {id: val}); // Commit immediately as they are single-line directives.
            }
        } else { // This is a sub-directive within an active block.
            // If there's no active block, this sub-directive is out of place.
            // 如果沒有活動區塊，則此子指令放置不當。
            if (!currentData) throw new Error(`Directive //! ${directive} cannot be used here / 指令 //! ${directive} 不能在此處使用`);
            parseSubDirective(currentData, directive, val); // Parse the sub-directive.
        }
        return {type: "directive", directive: directive, value: val};
    }

    function peg$f3(text) {
        const lineStr = text.join("");
        const trimmedLine = lineStr.trim();

        // Special handling for resource declarations in TEXTURE, SAMPLER, PARAMETER blocks.
        // 對於 TEXTURE, SAMPLER, PARAMETER 區塊中的資源宣告進行特殊處理。
        if (currentBlock === 'TEXTURE' || currentBlock === 'SAMPLER' || currentBlock === 'PARAMETER') {
            const match = trimmedLine.match(/var\s+([a-zA-Z0-9_]+)\s*:/); // Regex to find variable declaration.
            if (match) {
                currentData.isTemplate = true; // Mark as a template for resource creation.
                const name = match[1]; // Extract the resource name.
                const newResource = {...currentData, name: name, id: name}; // Create a new resource object.
                delete newResource.lines; // These are specific to COMMON blocks.
                delete newResource.isTemplate;

                // Push the new resource to the appropriate shaderInfo array.
                // 將新資源推送到相應的 shaderInfo 陣列中。
                if (currentBlock === 'TEXTURE') {
                    shaderInfo.textures.push(newResource);
                } else if (currentBlock === 'SAMPLER') {
                    shaderInfo.samplers.push(newResource);
                } else if (currentBlock === 'PARAMETER') {
                    shaderInfo.parameters.push(newResource);
                }
                return {type: "code", text: lineStr};
            }
        }

        // Accumulate code lines for COMMON and PASS blocks.
        // 累積 COMMON 和 PASS 區塊的程式碼行。
        if (currentBlock === 'COMMON') {
            currentData.lines.push(lineStr);
        } else if (currentBlock === 'PASS') {
            passCodeBuffer.push(lineStr);
        }
        return {type: "code", text: lineStr};
    }

    let peg$currPos = options.peg$currPos | 0;
    const peg$posDetailsCache = [{line: 1, column: 1}];
    let peg$maxFailPos = peg$currPos;
    let peg$maxFailExpected = options.peg$maxFailExpected || [];
    let peg$silentFails = options.peg$silentFails | 0;

    let peg$result;

    if (options.startRule) {
        if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function peg$getUnicode(pos = peg$currPos) {
        const cp = input.codePointAt(pos);
        if (cp === undefined) {
            return "";
        }
        return String.fromCodePoint(cp);
    }

    function peg$literalExpectation(text, ignoreCase) {
        return {type: "literal", text, ignoreCase};
    }

    function peg$classExpectation(parts, inverted, ignoreCase, unicode) {
        return {type: "class", parts, inverted, ignoreCase, unicode};
    }

    function peg$endExpectation() {
        return {type: "end"};
    }

    function peg$computePosDetails(pos) {
        let details = peg$posDetailsCache[pos];
        let p;

        if (details) {
            return details;
        } else {
            if (pos >= peg$posDetailsCache.length) {
                p = peg$posDetailsCache.length - 1;
            } else {
                p = pos;
                while (!peg$posDetailsCache[--p]) {
                }
            }

            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column,
            };

            while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                } else {
                    details.column++;
                }

                p++;
            }

            peg$posDetailsCache[pos] = details;

            return details;
        }
    }

    function peg$computeLocation(startPos, endPos, offset) {
        const startPosDetails = peg$computePosDetails(startPos);
        const endPosDetails = peg$computePosDetails(endPos);

        const res = {
            source: peg$source,
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column,
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column,
            },
        };
        return res;
    }

    function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
            return;
        }

        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
    }

    function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(
            peg$SyntaxError.buildMessage(expected, found),
            expected,
            found,
            location
        );
    }

    function peg$parsestart() {
        let s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseline();
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseline();
        }
        s1 = peg$f0();
        s0 = s1;

        return s0;
    }

    function peg$parseline() {
        let s0, s1;

        s0 = peg$parsedirective_line();
        if (s0 === peg$FAILED) {
            s0 = peg$parsecode_line();
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 10) {
                    s1 = peg$c0;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e0);
                    }
                }
                if (s1 !== peg$FAILED) {
                    s1 = peg$f1();
                }
                s0 = s1;
            }
        }

        return s0;
    }

    function peg$parsedirective_line() {
        let s0, s1, s3, s5;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c1) {
            s1 = peg$c1;
            peg$currPos += 3;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e1);
            }
        }
        if (s1 !== peg$FAILED) {
            peg$parse_();
            s3 = peg$parseidentifier();
            if (s3 !== peg$FAILED) {
                peg$parse_();
                s5 = peg$parserest_of_line();
                s0 = peg$f2(s3, s5);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }

        return s0;
    }

    function peg$parsecode_line() {
        let s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = input.charAt(peg$currPos);
        if (peg$r0.test(s2)) {
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e2);
            }
        }
        if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = input.charAt(peg$currPos);
                if (peg$r0.test(s2)) {
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e2);
                    }
                }
            }
        } else {
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 10) {
                s2 = peg$c0;
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                }
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            s0 = peg$f3(s1);
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }

        return s0;
    }

    function peg$parseidentifier() {
        let s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = input.charAt(peg$currPos);
        if (peg$r1.test(s2)) {
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e3);
            }
        }
        if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = input.charAt(peg$currPos);
                if (peg$r1.test(s2)) {
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                    }
                }
            }
        } else {
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
        } else {
            s0 = s1;
        }

        return s0;
    }

    function peg$parserest_of_line() {
        let s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = input.charAt(peg$currPos);
        if (peg$r0.test(s2)) {
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e2);
            }
        }
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = input.charAt(peg$currPos);
            if (peg$r0.test(s2)) {
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                }
            }
        }
        s0 = input.substring(s0, peg$currPos);

        return s0;
    }

    function peg$parse_() {
        let s0, s1;

        s0 = [];
        s1 = input.charAt(peg$currPos);
        if (peg$r2.test(s1)) {
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e4);
            }
        }
        while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = input.charAt(peg$currPos);
            if (peg$r2.test(s1)) {
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e4);
                }
            }
        }

        return s0;
    }


    // Initialize the Intermediate Representation (IR) structure.
    // 初始化 IR 結構
    const shaderInfo = {
        metadata: {use: {}, capability: {}},
        parameters: [],
        textures: [],
        samplers: [],
        passes: [],
        commonCode: ''
    };

    // Tracks the currently active block type (e.g., 'PARAMETER', 'TEXTURE', 'PASS').
    // 追蹤當前活動的區塊類型 (例如：'PARAMETER', 'TEXTURE', 'PASS')。
    let currentBlock = null;
    // Stores data for the current block being parsed.
    // 儲存當前正在解析的區塊資料。
    let currentData = null;
    // Buffer to accumulate code lines within a 'PASS' block.
    // 用於在 'PASS' 區塊內累積程式碼行的緩衝區。
    let passCodeBuffer = [];

    /**
     * Commits the parsed data of a block to the main shaderInfo structure.
     * 將解析後的區塊資料提交到主要的 shaderInfo 結構中。
     * @param {string} blockType - The type of the block (e.g., 'PARAMETER', 'COMMON').
     * @param {object} data - The parsed data for the block.
     */
    function commitBlock(blockType, data) {
        if (!blockType || !data || data.isTemplate) {
            currentData = null;
            return;
        }
        switch (blockType) {
            case 'PARAMETER':
                shaderInfo.parameters.push(data);
                break;
            case 'COMMON':
                shaderInfo.commonCode = data.lines.join('\n');
                break;
            case 'TEXTURE':
                shaderInfo.textures.push(data);
                break;
            case 'SAMPLER':
                shaderInfo.samplers.push(data);
                break;
            case 'PASS':
                shaderInfo.passes.push(data);
                break;
            case 'VERSION':
                shaderInfo.metadata.version = parseInt(data.id, 10);
                break;
            case 'SORT_NAME':
                shaderInfo.metadata.sortName = data.id;
                break;
            case 'USE':
                data.id.split(',').forEach(f => shaderInfo.metadata.use[f.trim().toUpperCase()] = true);
                break;
            case 'CAPABILITY':
                data.id.split(',').forEach(f => shaderInfo.metadata.capability[f.trim().toUpperCase()] = true);
                break;
        }
        currentData = null;
    }

    /**
     * Parses sub-directives within a block (e.g., //! DEFAULT, //! MIN for PARAMETER).
     * 解析區塊內部的子指令 (例如 PARAMETER 的 //! DEFAULT, //! MIN)。
     * @param {object} data - The current block's data object to populate.
     * @param {string} directive - The name of the sub-directive.
     * @param {string} value - The value of the sub-directive.
     */
    function parseSubDirective(data, directive, value) {
        const key = directive.toLowerCase();
        switch (key) {
            case 'in':
            case 'out':
                data[key] = value.split(',').map(s => s.trim());
                break;
            case 'block_size':
                data.blockSize = value.split(',').map(Number);
                if (data.blockSize.length === 1) data.blockSize.push(data.blockSize[0]); // Handle single value for block_size
                break;
            case 'num_threads':
                data.numThreads = value.split(',').map(Number);
                while (data.numThreads.length < 3) data.numThreads.push(1); // Ensure 3 components for num_threads
                break;
            case 'default':
            case 'min':
            case 'max':
            case 'step':
                data[key] = parseFloat(value);
                break;
            case 'format':
                data[key] = value.toLowerCase() === 'r16g16b16a16_float' ? 'rgba16float' : value;
                break;
            default:
                data[key] = value;
        }
    }

    peg$result = peg$startRuleFunction();

    const peg$success = (peg$result !== peg$FAILED && peg$currPos === input.length);

    function peg$throw() {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input.length ? peg$getUnicode(peg$maxFailPos) : null,
            peg$maxFailPos < input.length
                ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
                : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
    }

    if (options.peg$library) {
        return /** @type {any} */ ({
            peg$result,
            peg$currPos,
            peg$FAILED,
            peg$maxFailExpected,
            peg$maxFailPos,
            peg$success,
            peg$throw: peg$success ? undefined : peg$throw,
        });
    }
    if (peg$success) {
        return peg$result;
    } else {
        peg$throw();
    }
}

// src/runtime/ResourceManager.js

/**
 * @fileoverview
 * - EN: Manages the creation, storage, and retrieval of WebGPU resources.
 *   This class handles GPUTexture, GPUSampler, and GPUBuffer objects based on the shader IR,
 *   providing a central location to access these resources by name.
 * - TW: 管理 WebGPU 資源的建立、儲存和檢索。
 *   此類別根據著色器 IR 處理 GPUTexture、GPUSampler 和 GPUBuffer 物件，
 *   提供一個中心位置，可以按名稱存取這些資源。
 */

let GPUDevice$1, GPUTextureUsage, GPUBufferUsage;

/**
 * - EN: In a Node.js environment, native WebGPU objects don't exist.
 *   We check for their existence on the global scope. If they don't exist,
 *   they will remain `undefined`, which is safe for the CLI code path
 *   as it doesn't instantiate or use any GPU-related objects.
 * - TW: 在 Node.js 環境中，原生 WebGPU 物件不存在。
 *   我們檢查它們是否在全域範圍內存在。如果不存在，
 *   它們將保持 `undefined`，這對於 CLI 程式碼路徑是安全的，
 *   因為它不實例化或使用任何與 GPU 相關的物件。
 */
try {
    /**
     * - EN: This will only succeed in a browser-like environment with WebGPU support.
     * - TW: 這只會在支援 WebGPU 的瀏覽器環境中成功。
     */
    if (globalThis.GPUDevice) {
        GPUDevice$1 = globalThis.GPUDevice;
        GPUTextureUsage = globalThis.GPUTextureUsage;
        GPUBufferUsage = globalThis.GPUBufferUsage;
    }
    /**
     * - EN: In Node.js or a non-WebGPU environment, these will remain undefined.
     *   This is safe because the CLI path does not use this functionality.
     * - TW: 在 Node.js 或非 WebGPU 環境中，這些將保持未定義。
     *   這很安全，因為 CLI 路徑不使用此功能。
     */
} catch (e) {
    /**
     * - EN: Ignore any errors during this detection phase.
     *   The variables will simply remain undefined.
     * - TW: 在此檢測階段忽略任何錯誤。
     *   變數將簡單地保持未定義。
     */
}


/**
 * - EN: ResourceManager Implementation
 * - TW: 資源管理器實作
 */

class ResourceManager {
    /**
     * @param {GPUDevice} [device]
     * - EN: The active WebGPU device. If not provided, a mock device will be used.
     * - TW: 作用中的 WebGPU 裝置。如果未提供，將使用模擬裝置。
     */
    constructor(device) {
        /** @type {GPUDevice} */
        /**
         * - EN: Use provided device or a mock device.
         * - TW: 使用提供的裝置或模擬裝置。
         */
        this.device = device || new GPUDevice$1();
        /**
         * - EN: Stores GPUTexture objects, mapped by their unique names.
         * - TW: 儲存 GPUTexture 物件，按其唯一名稱映射。
         * @type {Map<string, import('./WebGPU-mock.js').GPUTexture>}
         */
        this.textures = new Map();
        /**
         * - EN: Stores GPUSampler objects, mapped by their unique names.
         * - TW: 儲存 GPUSampler 物件，按其唯一名稱映射。
         * @type {Map<string, import('./WebGPU-mock.js').GPUSampler>}
         */
        this.samplers = new Map();
        /**
         * - EN: Stores metadata for each uniform, including its offset and size within the main buffer.
         * - TW: 儲存每個 uniform 的元資料，包括其在主緩衝區中的偏移量和大小。
         * @type {Map<string, {buffer: import('./WebGPU-mock.js').GPUBuffer, offset: number, size: number}>}
         */
        this.uniforms = new Map();
        /**
         * - EN: A single GPU buffer used to store all uniform parameters.
         * - TW: 用於儲存所有 uniform 參數的單一 GPU 緩衝區。
         * @type {import('./WebGPU-mock.js').GPUBuffer}
         */
        this.uniformBuffer = null;
    }

    /**
     * - EN: Initializes all GPU resources based on the parsed shader IR.
     * - TW: 根據解析後的著色器 IR 初始化所有 GPU 資源。
     * @param {import('./ShaderParser.js').WGFXShaderInfo} shaderInfo
     * - EN: Parsed shader information from Parser.js.
     * - TW: 來自 Parser.js 的解析後著色器資訊。
     */

    /**
     * - EN: Initializes all GPU resources based on the parsed shader IR.
     * - TW: 根據解析後的著色器 IR 初始化所有 GPU 資源。
     * @param {import('./ShaderParser.js').WGFXShaderInfo} shaderInfo
     * - EN: Parsed shader information from Parser.js.
     * - TW: 來自 Parser.js 的解析後著色器資訊。
     */
    /**
     * - EN: Initializes all GPU resources based on the parsed shader IR.
     * - TW: 根據解析後的著色器 IR 初始化所有 GPU 資源。
     * @param {import('./ShaderParser.js').WGFXShaderInfo} shaderInfo
     * - EN: Parsed shader information from Parser.js.
     * - TW: 來自 Parser.js 的解析後著色器資訊。
     */
    initialize(shaderInfo, externalResources = {}) {
        const context = {};

        // 1. [優先] 載入外部定義的常數 (如 INPUT_WIDTH/HEIGHT)
        if (externalResources.defines) {
            Object.assign(context, externalResources.defines);
        }

        // 2. 建立外部紋理 (INPUT, OUTPUT 等)
        if (externalResources.textures) {
            for (const [name, descriptor] of Object.entries(externalResources.textures)) {
                this.createTexture(name, descriptor);
            }
        }

        // 3. [後備] 如果 defines 沒給尺寸，嘗試從剛剛建立的 INPUT 紋理反查
        if ((!context['INPUT_WIDTH'] || !context['INPUT_HEIGHT']) && this.textures.has('INPUT')) {
            const inputTexture = this.getTexture('INPUT');
            if (inputTexture) {
                if (!context['INPUT_WIDTH']) context['INPUT_WIDTH'] = inputTexture.width;
                if (!context['INPUT_HEIGHT']) context['INPUT_HEIGHT'] = inputTexture.height;
            }
        }

        // --- Safe Math Parser (CSP Compliant: No eval/new Function) ---
        // 實作一個簡單的遞迴下降解析器，支援 +, -, *, /, %, () 和小數
        const parseMathExpression = (str) => {
            let pos = 0;
            // 移除所有空白
            str = str.replace(/\s+/g, '');

            const peek = () => str[pos];
            const consume = () => str[pos++];

            const parseFactor = () => {
                if (peek() === '(') {
                    consume(); // 吃掉 '('
                    const result = parseExpr();
                    if (peek() !== ')') throw new Error("Expected ')'");
                    consume(); // 吃掉 ')'
                    return result;
                }

                // 解析數字 (含負號和小數點)
                let numStr = '';
                if (peek() === '-') {
                    numStr += consume();
                }
                while (pos < str.length && (/[0-9.]/).test(peek())) {
                    numStr += consume();
                }
                if (numStr === '') throw new Error(`Unexpected char: '${peek()}' at pos ${pos}`);
                return parseFloat(numStr);
            };

            const parseTerm = () => {
                let left = parseFactor();
                while (pos < str.length) {
                    const op = peek();
                    if (op === '*' || op === '/' || op === '%') {
                        consume();
                        const right = parseFactor();
                        if (op === '*') left *= right;
                        else if (op === '/') left /= right;
                        else if (op === '%') left %= right;
                    } else {
                        break;
                    }
                }
                return left;
            };

            const parseExpr = () => {
                let left = parseTerm();
                while (pos < str.length) {
                    const op = peek();
                    if (op === '+' || op === '-') {
                        consume();
                        const right = parseTerm();
                        if (op === '+') left += right;
                        else if (op === '-') left -= right;
                    } else {
                        break;
                    }
                }
                return left;
            };

            const result = parseExpr();
            return result;
        };

        const evaluate = (expr, ctx) => {
            if (typeof expr !== 'string') return expr;

            // 替換變數
            let evaluatedExpr = expr;
            for (const key in ctx) {
                const regex = new RegExp('\\b' + key + '\\b', 'g');
                evaluatedExpr = evaluatedExpr.replace(regex, ctx[key]);
            }

            try {
                // 如果替換後只是單純的數字字串，直接轉換 (最快)
                if (!isNaN(Number(evaluatedExpr))) {
                    return Math.ceil(Number(evaluatedExpr));
                }
                // 否則使用安全的解析器計算
                return Math.ceil(parseMathExpression(evaluatedExpr));
            } catch (e) {
                console.error("Evaluation failed. Context:", ctx);
                throw new Error(`Cannot evaluate expression: "${expr}". Resulted in: "${evaluatedExpr}". Error: ${e.message}`);
            }
        };

        /**
         * - EN: Create textures defined in the shader.
         * - TW: 建立著色器中定義的紋理。
         */
        shaderInfo.textures.forEach(tex => {
            if (this.textures.has(tex.name)) return; // Already created externally

            const width = evaluate(tex.width, context);
            const height = evaluate(tex.height, context);

            if (!width || !height) {
                throw new Error(`Could not determine size for texture ${tex.name}. Width or height expression is invalid.`);
            }

            const descriptor = {
                size: [width, height],
                format: tex.format?.toLowerCase() || 'rgba8unorm',
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
            };
            this.createTexture(tex.name, descriptor);
        });

        /**
         * - EN: Create samplers defined in the shader.
         * - TW: 建立著色器中定義的取樣器。
         */
        shaderInfo.samplers.forEach(samp => {
            const descriptor = {
                magFilter: samp.filter === 'LINEAR' ? 'linear' : 'nearest',
                minFilter: samp.filter === 'LINEAR' ? 'linear' : 'nearest',
                addressModeU: samp.address === 'WRAP' ? 'repeat' : 'clamp-to-edge',
                addressModeV: samp.address === 'WRAP' ? 'repeat' : 'clamp-to-edge',
            };
            this.createSampler(samp.name, descriptor);
        });

        /**
         * - EN: Create a single uniform buffer to store all parameters.
         * - TW: 建立一個單一的 uniform 緩衝區來儲存所有參數。
         */
        if (shaderInfo.parameters.length > 0) {
            let totalSize = 0;
            shaderInfo.parameters.forEach(param => {
                const size = 4; // Assuming 4 bytes (f32/i32) for simplicity
                this.uniforms.set(param.name, {buffer: null, offset: totalSize, size});
                totalSize += size;
            });

            const alignedSize = Math.ceil(totalSize / 16) * 16;

            this.uniformBuffer = this.device.createBuffer({
                size: alignedSize,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });

            this.uniforms.forEach(u => u.buffer = this.uniformBuffer);
        }

        console.log("ResourceManager: Resources initialized.", {
            textures: [...this.textures.keys()],
            samplers: [...this.samplers.keys()],
            uniforms: [...this.uniforms.keys()],
            context: context
        });
    }
    /**
     * - EN: Creates or replaces a GPUTexture in the manager.
     * - TW: 在管理器中建立或替換 GPUTexture。
     * @param {string} name
     * - EN: The unique name of the texture.
     * - TW: 紋理的唯一名稱。
     * @param {GPUTextureDescriptor} descriptor
     * - EN: The descriptor for the texture.
     * - TW: 紋理描述符。
     * @returns {GPUTexture}
     * - EN: The created GPUTexture.
     * - TW: 建立的 GPUTexture。
     */
    createTexture(name, descriptor) {
        /**
         * - EN: If a texture with the same name exists, destroy the old one first.
         * - TW: 如果存在同名紋理，則先銷毀舊紋理。
         */
        if (this.textures.has(name)) {
            this.textures.get(name).destroy();
        }
        const texture = this.device.createTexture(descriptor);
        /**
         * - EN: Set label for debugging.
         * - TW: 設定標籤以進行調試。
         */
        texture.label = name;
        this.textures.set(name, texture);
        return texture;
    }

    /**
     * - EN: Retrieves a texture by its name.
     * - TW: 按名稱檢索紋理。
     * @param {string} name
     * - EN: The name of the texture.
     * - TW: 紋理的名稱。
     * @returns {GPUTexture | undefined}
     * - EN: The texture object or undefined if not found.
     * - TW: 紋理物件，如果找不到則為 undefined。
     */
    getTexture(name) {
        return this.textures.get(name);
    }

    /**
     * - EN: Creates a new GPUSampler.
     * - TW: 建立新的 GPUSampler。
     * @param {string} name
     * - EN: The unique name of the sampler.
     * - TW: 取樣器的唯一名稱。
     * @param {GPUSamplerDescriptor} descriptor
     * - EN: The descriptor for the sampler.
     * - TW: 取樣器描述符。
     * @returns {GPUSampler}
     * - EN: The created GPUSampler.
     * - TW: 建立的 GPUSampler。
     */
    createSampler(name, descriptor) {
        const sampler = this.device.createSampler(descriptor);
        this.samplers.set(name, sampler);
        return sampler;
    }

    /**
     * - EN: Uploads image data (ImageBitmap, VideoFrame, etc.) to a specified GPUTexture.
     * - TW: 將圖像資料 (ImageBitmap, VideoFrame 等) 上傳到指定的 GPUTexture。
     * @param {string} name - The name of the texture (e.g., 'INPUT').
     * @param {ImageBitmap | VideoFrame | HTMLCanvasElement} image - The source image data.
     */
    /**
     * - EN: Updates a texture's content from an ImageBitmap, HTMLVideoElement, HTMLCanvasElement, or OffscreenCanvas
     * - TW: 從 ImageBitmap、HTMLVideoElement、HTMLCanvasElement 或 OffscreenCanvas 更新紋理內容
     *
     * @param {string} textureName - The name of the texture to update
     * @param {ImageBitmap | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas} imageSource - The image source
     */
    updateTextureFromImage(textureName, imageSource) {
        const texture = this.textures.get(textureName);
        if (!texture) {
            throw new Error(`Texture "${textureName}" not found in ResourceManager.`);
        }

        // Get the size of the image source
        let width, height;
        if (imageSource instanceof HTMLVideoElement) {
            width = imageSource.videoWidth;
            height = imageSource.videoHeight;
        } else {
            width = imageSource.width;
            height = imageSource.height;
        }

        // Validate dimensions
        if (width === 0 || height === 0) {
            throw new Error(`Image source has invalid dimensions: ${width}x${height}`);
        }

        // Validate texture size matches
        if (texture.width !== width || texture.height !== height) {
            console.warn(
                `Texture "${textureName}" size (${texture.width}x${texture.height}) ` +
                `does not match image size (${width}x${height}). Texture will be recreated.`
            );
            // In production, you might want to recreate the texture here
            // For now, we'll throw an error
            throw new Error(`Texture size mismatch for "${textureName}"`);
        }

        // CRITICAL FIX: Use the correct WebGPU API method
        // The correct method name is copyExternalImageToTexture, not copyExternalImageToBufferOrTexture
        this.device.queue.copyExternalImageToTexture(
            {
                source: imageSource,
                flipY: false  // Set to true if you need to flip the image vertically
            },
            {
                texture: texture,
                mipLevel: 0,
                origin: { x: 0, y: 0, z: 0 }
            },
            {
                width: width,
                height: height,
                depthOrArrayLayers: 1
            }
        );
    }

    /**
     * - EN: Retrieves a sampler by its name.
     * - TW: 按名稱檢索取樣器。
     * @param {string} name
     * - EN: The name of the sampler.
     * - TW: 取樣器的名稱。
     * @returns {GPUSampler | undefined}
     * - EN: The sampler object or undefined if not found.
     * - TW: 取樣器物件，如果找不到則為 undefined。
     */
    getSampler(name) {
        return this.samplers.get(name);
    }

    /**
     * - EN: Retrieves the single uniform buffer for all parameters.
     * - TW: 檢索所有參數的單一 uniform 緩衝區。
     * @returns {GPUBuffer | null} - EN: The uniform buffer object, or null if no parameters exist. - TW: 統一緩衝區物件，如果不存在參數則為 null。
     */
    getUniformBuffer() {
        return this.uniformBuffer;
    }

    /**
     * - EN: Retrieves metadata for a specific uniform.
     * - TW: 檢索特定 uniform 的元資料。
     * @param {string} name
     * - EN: The name of the uniform parameter.
     * - TW: uniform 參數的名稱。
     * @returns {{buffer: GPUBuffer, offset: number, size: number} | undefined}
     * - EN: Metadata for the uniform, or undefined if not found.
     * - TW: uniform 的元資料，如果找不到則為 undefined。
     */
    getUniform(name) {
        return this.uniforms.get(name);
    }

    /**
     * - EN: Destroys all managed GPU resources to prevent memory leaks.
     * - TW: 銷毀所有管理的 GPU 資源以防止記憶體洩漏。
     */
    dispose() {
        this.textures.forEach(texture => texture.destroy());
        /**
         * - EN: Destroy all GPU textures.
         * - TW: 銷毀所有 GPU 紋理。
         */
        this.uniforms.clear();
        /**
         * - EN: Clear uniform metadata.
         * - TW: 清除 uniform 元資料。
         */
        if (this.uniformBuffer) {
            this.uniformBuffer.destroy();
            /**
             * - EN: Destroy the uniform buffer.
             * - TW: 銷毀 uniform 緩衝區。
             */
        }
        this.textures.clear();
        /**
         * - EN: Clear the texture map.
         * - TW: 清除紋理映射。
         */
        this.samplers.clear();
        /**
         * - EN: Clear the sampler map.
         * - TW: 清除取樣器映射。
         */
        /**
         * - EN: All GPU resources destroyed.
         * - TW: 所有 GPU 資源已銷毀。
         */
        console.log("ResourceManager: All GPU resources destroyed.");
    }
}

// src/runtime/PipelineManager.js

/**
 * - EN: Manages the creation and scheduling of WebGPU compute pipelines.
 * - TW: 管理 WebGPU 計算管線的建立和調度。
 */
class PipelineManager {
    constructor(device, resourceManager) {
        this.device = device;
        this.resourceManager = resourceManager;
        this.pipelines = new Map();

        // Setup uncaptured error handler for debugging
        this.device.addEventListener('uncapturederror', event => {
            console.error('WebGPU Uncaptured Error:', event.error.message);
        });
    }

    /**
     * - EN: Asynchronously creates compute pipelines for all passes.
     * - TW: 非同步建立所有通道的計算管線。
     */
    async createPipelines(shaderInfo, generatedModules) {
        this.pipelines.clear();

        for (const module of generatedModules) {
            const pass = shaderInfo.passes.find(p => p.index === module.passIndex);
            if (!pass) {
                console.warn(`PipelineManager: Pass ${module.passIndex} not found in shaderInfo.`);
                continue;
            }

            console.log(`建立 Pass ${module.passIndex} 的管線...`);
            console.log(`WGSL 程式碼長度: ${module.wgslCode.length} 字元`);

            try {
                // 1. Create GPUShaderModule with error scope
                this.device.pushErrorScope('validation');

                const shaderModule = this.device.createShaderModule({
                    code: module.wgslCode,
                    label: `Pass ${module.passIndex} Shader Module`
                });

                const shaderError = await this.device.popErrorScope();
                if (shaderError) {
                    console.error('Shader Module 建立錯誤:', shaderError.message);
                    throw shaderError;
                }

                // Check compilation info
                const compilationInfo = await shaderModule.getCompilationInfo();
                if (compilationInfo.messages.length > 0) {
                    console.group(`Shader 編譯訊息 (Pass ${module.passIndex}):`);
                    for (const msg of compilationInfo.messages) {
                        const level = msg.type === 'error' ? 'ERROR' : msg.type === 'warning' ? 'WARN' : 'INFO';
                        console.log(`${level} Line ${msg.lineNum}:${msg.linePos} - ${msg.message}`);

                        // Show context
                        if (msg.lineNum) {
                            const lines = module.wgslCode.split('\n');
                            const contextStart = Math.max(0, msg.lineNum - 2);
                            const contextEnd = Math.min(lines.length, msg.lineNum + 2);
                            console.log('Context:');
                            for (let i = contextStart; i < contextEnd; i++) {
                                const prefix = (i + 1) === msg.lineNum ? '>>> ' : '    ';
                                console.log(`${prefix}${i + 1}: ${lines[i]}`);
                            }
                        }
                    }
                    console.groupEnd();

                    // If there are errors, stop
                    const hasErrors = compilationInfo.messages.some(m => m.type === 'error');
                    if (hasErrors) {
                        throw new Error(`Shader compilation failed with ${compilationInfo.messages.filter(m => m.type === 'error').length} error(s)`);
                    }
                }

                console.log('Shader Module 建立成功');

                // 2. Create GPUBindGroupLayout
                const bindingMap = new Map();

                // Add Samplers
                module.resources.samplers.forEach(samp => {
                    console.log(`Sampler "${samp.name}" -> @binding(${samp.binding})`);
                    bindingMap.set(samp.binding, {
                        binding: samp.binding,
                        visibility: GPUShaderStage.COMPUTE,
                        sampler: {type: 'filtering'}
                    });
                });

                // Add Uniforms (binding 1 if present)
                if (module.resources.parameters.length > 0) {
                    console.log('Uniforms -> @binding(1)');
                    bindingMap.set(1, {
                        binding: 1,
                        visibility: GPUShaderStage.COMPUTE,
                        buffer: {type: 'uniform'}
                    });
                }

                // Add Textures
                module.resources.textures.forEach(tex => {
                    const texType = tex.isStorage ? 'storage' : 'sampled';
                    const normalizedFormat = (tex.format || 'rgba8unorm').toLowerCase().replace(/_/g, '');
                    console.log(`Texture "${tex.name}" (${texType}, ${normalizedFormat}) -> @binding(${tex.binding})`);

                    if (tex.isStorage) {
                        const validWriteStorageFormats = [
                            'r32float', 'r32sint', 'r32uint',
                            'rgba16float', 'rgba16sint', 'rgba16uint',
                            'rgba32float', 'rgba32sint', 'rgba32uint',
                            'rg32float', 'rg32sint', 'rg32uint'
                        ];

                        if (!validWriteStorageFormats.includes(normalizedFormat)) {
                            console.error(`Invalid write storage texture format: ${normalizedFormat}`);
                            throw new Error(
                                `Texture "${tex.name}" has invalid storage format "${normalizedFormat}". ` +
                                `Valid formats for write access: ${validWriteStorageFormats.join(', ')}`
                            );
                        }

                        bindingMap.set(tex.binding, {
                            binding: tex.binding,
                            visibility: GPUShaderStage.COMPUTE,
                            storageTexture: {
                                format: normalizedFormat,
                                access: 'write-only'
                            }
                        });
                    } else {
                        bindingMap.set(tex.binding, {
                            binding: tex.binding,
                            visibility: GPUShaderStage.COMPUTE,
                            texture: {sampleType: 'float'}
                        });
                    }
                });

                const bindGroupLayoutEntries = Array.from(bindingMap.values())
                    .sort((a, b) => a.binding - b.binding);

                console.log(`BindGroupLayout entries (${bindGroupLayoutEntries.length} total)`);

                this.device.pushErrorScope('validation');

                const bindGroupLayout = this.device.createBindGroupLayout({
                    entries: bindGroupLayoutEntries,
                    label: `Pass ${module.passIndex} Bind Group Layout`
                });

                const layoutError = await this.device.popErrorScope();
                if (layoutError) {
                    console.error('BindGroupLayout 建立錯誤:', layoutError.message);
                    throw layoutError;
                }

                console.log('BindGroupLayout 建立成功');

                // 3. Create GPUPipelineLayout
                this.device.pushErrorScope('validation');

                const pipelineLayout = this.device.createPipelineLayout({
                    bindGroupLayouts: [bindGroupLayout],
                    label: `Pass ${module.passIndex} Pipeline Layout`
                });

                const pipelineLayoutError = await this.device.popErrorScope();
                if (pipelineLayoutError) {
                    console.error('PipelineLayout 建立錯誤:', pipelineLayoutError.message);
                    throw pipelineLayoutError;
                }

                console.log('PipelineLayout 建立成功');

                // 4. Create GPUComputePipeline
                this.device.pushErrorScope('validation');

                const computePipeline = await this.device.createComputePipelineAsync({
                    layout: pipelineLayout,
                    compute: {
                        module: shaderModule,
                        entryPoint: 'main_cs',
                    },
                    label: `Pass ${module.passIndex} Compute Pipeline`
                });

                const pipelineError = await this.device.popErrorScope();
                if (pipelineError) {
                    console.error('ComputePipeline 建立錯誤:', pipelineError.message);
                    throw pipelineError;
                }

                await this.device.queue.submit([]);

                console.log(`Pass ${module.passIndex} 管線建立成功`);

                this.pipelines.set(module.passIndex, {
                    shaderModule,
                    bindGroupLayout,
                    pipelineLayout,
                    computePipeline,
                    resources: module.resources,
                    passInfo: pass
                });

            } catch (error) {
                console.error(`Pass ${module.passIndex} 管線建立失敗:`, error);

                console.group(`Pass ${module.passIndex} 完整 WGSL 程式碼:`);
                const lines = module.wgslCode.split('\n');
                lines.forEach((line, idx) => {
                    console.log(`${(idx + 1).toString().padStart(4)}: ${line}`);
                });
                console.groupEnd();

                throw error;
            }
        }

        console.log(`成功建立 ${this.pipelines.size} 個管線`);
    }

    /**
     * - EN: Encodes commands to dispatch a specific compute pass.
     * - TW: 編碼調度特定計算通道的命令。
     */
    dispatchPass(passInfo, commandEncoder) {
        const storedPipeline = this.pipelines.get(passInfo.index);
        if (!storedPipeline) {
            throw new Error(`找不到通道 ${passInfo.index} 的管線。是否已編譯?`);
        }

        const {computePipeline, bindGroupLayout, resources, passInfo: originalPassInfo} = storedPipeline;

        const bindingMap = new Map();

        resources.samplers.forEach(samp => {
            const sampler = this.resourceManager.getSampler(samp.name);
            if (!sampler) {
                if (samp.name === 'sam') {
                    const defaultSampler = this.device.createSampler({
                        magFilter: 'linear',
                        minFilter: 'linear',
                    });
                    bindingMap.set(samp.binding, {
                        binding: samp.binding,
                        resource: defaultSampler
                    });
                } else {
                    throw new Error(`Sampler ${samp.name} not found in ResourceManager.`);
                }
            } else {
                bindingMap.set(samp.binding, {
                    binding: samp.binding,
                    resource: sampler
                });
            }
        });

        if (resources.parameters.length > 0) {
            const uniformBuffer = this.resourceManager.getUniformBuffer();
            if (!uniformBuffer) {
                throw new Error('Uniform buffer not found in ResourceManager.');
            }
            bindingMap.set(1, {
                binding: 1,
                resource: {buffer: uniformBuffer}
            });
        }

        resources.textures.forEach(tex => {
            const texture = this.resourceManager.getTexture(tex.name);
            if (!texture) {
                throw new Error(`Texture ${tex.name} not found in ResourceManager.`);
            }
            bindingMap.set(tex.binding, {
                binding: tex.binding,
                resource: texture.createView()
            });
        });

        const bindGroupEntries = Array.from(bindingMap.values())
            .sort((a, b) => a.binding - b.binding);

        const bindGroup = this.device.createBindGroup({
            layout: bindGroupLayout,
            entries: bindGroupEntries,
            label: `Pass ${passInfo.index} Bind Group`
        });

        const passEncoder = commandEncoder.beginComputePass();
        passEncoder.setPipeline(computePipeline);
        passEncoder.setBindGroup(0, bindGroup);

        const outputTextureName = originalPassInfo.out[0];
        const outputTexture = this.resourceManager.getTexture(outputTextureName);
        const workgroupSize = originalPassInfo.numThreads;

        const dispatchX = Math.ceil(outputTexture.width / workgroupSize[0]);
        const dispatchY = Math.ceil(outputTexture.height / workgroupSize[1]);

        passEncoder.dispatchWorkgroups(dispatchX, dispatchY, 1);
        passEncoder.end();
    }

    dispose() {
        this.pipelines.clear();
        console.log('PipelineManager: All pipeline states cleared.');
    }
}

// src/runtime/WGSLCodeGenerator.js
/**
 * - EN: Assembles a complete WGSL shader module from WGFX IR objects.
 * - TW: 從 WGFX IR 物件組裝完整的 WGSL 著色器模組。
 */

class WGSLCodeGenerator {
    constructor() {
    }

    /**
     * - EN: Determines if a texture format is valid for Storage Texture write access
     * - TW: 判斷紋理格式是否有效可用於 Storage Texture 寫入存取
     */
    _isValidStorageFormat(format) {
        const validStorageFormats = [
            'r32float', 'r32sint', 'r32uint',
            'rgba16float', 'rgba16sint', 'rgba16uint',
            'rgba32float', 'rgba32sint', 'rgba32uint',
            'rg32float', 'rg32sint', 'rg32uint'
        ];
        return validStorageFormats.includes(format.toLowerCase().replace(/_/g, ''));
    }

    /**
     * - EN: Upgrades texture format to a storage-compatible format
     * - TW: 將紋理格式升級為相容於 Storage 的格式
     */
    _upgradeToStorageFormat(format) {
        const normalizedFormat = format.toLowerCase().replace(/_/g, '');

        // 8-bit formats must be upgraded to rgba16float for storage use
        if (normalizedFormat === 'rgba8unorm' || normalizedFormat === 'bgra8unorm') {
            return 'rgba16float';
        }

        // 16-bit formats are already valid
        if (normalizedFormat.includes('rgba16') || normalizedFormat.includes('r16')) {
            return normalizedFormat;
        }

        // 32-bit formats are already valid
        if (normalizedFormat.includes('32')) {
            return normalizedFormat;
        }

        // Default fallback: upgrade to rgba16float
        console.warn(`Unknown format "${format}" upgraded to rgba16float for storage texture compatibility`);
        return 'rgba16float';
    }

    /**
     * - EN: Preprocesses pass code to fix WGSL type errors and syntax issues.
     * - TW: 預處理通道程式碼以修正 WGSL 型別錯誤和語法問題。
     */
    _preprocessPassCode(passCode, passIndex) {
        let processedCode = passCode;

        // Fix WGSL type error: vec2<u32> + f32
        processedCode = processedCode.replace(/\(gxy \+ 0\.5f\)/g, '(MF2(gxy) + 0.5f)');

        // Replace threadId.x with local_id.x
        processedCode = processedCode.replace(/threadId\.x/g, 'local_id.x');

        // Apply gxy fixes based on passIndex
        if (passIndex === 1) {
            processedCode = processedCode.replace(
                /let gxy = \(Rmp8x8\(local_id\.x\) << 1u\) \+ workgroup_id\.xy;/,
                'let gxy = (Rmp8x8(local_id.x) * 2u) + workgroup_id.xy;'
            );
        } else if (passIndex >= 2 && passIndex <= 7) {
            processedCode = processedCode.replace(
                /let gxy: uint2\s*=\s*Rmp8x8\(local_id\.x\) \+ blockStart;/,
                'let gxy: uint2 = Rmp8x8(local_id.x) + workgroup_id.xy * 8u;'
            );
        } else if (passIndex === 8) {
            processedCode = processedCode.replace(
                /let gxy: uint2 = Rmp8x8\(local_id\.x\) \+ workgroup_id\.xy;/,
                'let gxy: uint2 = Rmp8x8(local_id.x) + workgroup_id.xy * 8u;'
            );
        }

        // Fix variable redeclarations
        processedCode = processedCode.replace(
            /var\s+(a1|b1|c1|d1|e1|f1|g1|h1|i1|na1|nb1|nc1|nd1|ne1|nf1|ng1|nh1|ni1|na2|nb2|nc2|nd2|ne2|nf2|ng2|nh2|ni2|na3|nb3|nc3|nd3|ne3|nf3|ng3|nh3|ni3)\s+=\s+max\(\1,\s+MF4\(0\.0\)\);/g,
            '$1 = max($1, MF4(0.0));'
        );

        return processedCode;
    }

    /**
     * - EN: Assembles final WGSL shader modules from parsed shader information (IR).
     * - TW: 從解析後的著色器資訊 (IR) 組裝最終的 WGSL 著色器模組。
     */
    generate(shaderInfo) {
        const generatedModules = [];

        // Inject common code block
        const commonCode = shaderInfo.commonCode
            ? `// --- 通用程式碼 ---\n${shaderInfo.commonCode}\n\n`
            : '';

        // Generate uniform buffer structure if parameters exist
        let uniformBufferCode = '';
        if (shaderInfo.parameters.length > 0) {
            uniformBufferCode += `struct Uniforms {\n`;
            shaderInfo.parameters.forEach(p => {
                const type = p.type === 'int' ? 'i32' : 'f32';
                uniformBufferCode += `    ${p.name}: ${type},\n`;
            });
            uniformBufferCode += `};\n`;
            uniformBufferCode += `@group(0) @binding(1) var<uniform> uniforms: Uniforms;\n\n`;
        }

        // Process each pass
        shaderInfo.passes.forEach(pass => {
            let wgsl = `// 由 WGFX 組裝器生成 - 時間戳記: ${Date.now()} - Pass ${pass.index}\n\n`;
            wgsl += commonCode;

            // Declare default sampler
            wgsl += `@group(0) @binding(0) var sam: sampler;\n\n`;
            wgsl += uniformBufferCode;

            // Initialize resource tracking
            const passResources = {
                textures: [],
                samplers: [],
                parameters: shaderInfo.parameters
            };

            // Add default sampler
            passResources.samplers.push({
                name: 'sam',
                binding: 0,
                group: 0,
                filter: 'LINEAR'
            });

            // Collect textures and samplers used by this pass
            const usedTextureNames = new Set([...pass.in, ...pass.out]);

            // Add globally declared samplers
            shaderInfo.samplers.forEach(resource => {
                if (resource.name !== 'sam' && !passResources.samplers.some(s => s.name === resource.name)) {
                    passResources.samplers.push(resource);
                }
            });

            // Allocate bindings (sam:0, uniforms:1 if exists, then textures/samplers from 2 or 1)
            let bindingIndex = (shaderInfo.parameters.length > 0) ? 2 : 1;

            // Process textures
            shaderInfo.textures.forEach(tex => {
                // Check if this texture is used by this pass
                const isUsed = [...usedTextureNames].some(usedName =>
                    tex.name === usedName || tex.name.startsWith(usedName + "_")
                );

                if (!isUsed) return;

                // Determine texture usage (Sampled vs Storage)
                const isOutputInThisPass = pass.out.includes(tex.name);
                let isStorage = false;

                if (tex.name === 'OUTPUT') {
                    isStorage = true;
                } else if (tex.name === 'INPUT') {
                    isStorage = false; // INPUT is always read-only (Sampled)
                } else if (isOutputInThisPass) {
                    isStorage = true; // Output textures must be Storage
                } else {
                    isStorage = false; // Other cases (inputs) are Sampled
                }

                // Process format and compatibility
                let format = (tex.format || 'rgba8unorm').toLowerCase().replace(/_/g, '');

                // CRITICAL FIX: Upgrade format for storage textures
                if (isStorage) {
                    const originalFormat = format;
                    format = this._upgradeToStorageFormat(format);

                    if (originalFormat !== format) {
                        console.log(`Pass ${pass.index}: Upgraded texture "${tex.name}" format from ${originalFormat} to ${format} for storage compatibility`);
                    }

                    // Double-check format validity
                    if (!this._isValidStorageFormat(format)) {
                        console.error(`Pass ${pass.index}: Invalid storage format "${format}" for texture "${tex.name}"`);
                        throw new Error(`Texture "${tex.name}" has invalid storage format "${format}". Valid formats: r32float, rgba16float, rgba32float, etc.`);
                    }
                }

                // Generate WGSL texture declaration
                let textureType;
                if (isStorage) {
                    textureType = `texture_storage_2d<${format}, write>`;
                } else {
                    textureType = `texture_2d<f32>`;
                }

                const currentBinding = bindingIndex++;
                wgsl += `@group(0) @binding(${currentBinding}) var ${tex.name}: ${textureType};\n`;

                // Store resource info with corrected format
                passResources.textures.push({
                    ...tex,
                    format: format, // Use corrected format
                    binding: currentBinding,
                    group: 0,
                    isStorage: isStorage
                });
            });

            // Declare additional samplers (excluding 'sam')
            shaderInfo.samplers.forEach(samp => {
                if (samp.name !== 'sam') {
                    const currentBinding = bindingIndex++;
                    wgsl += `@group(0) @binding(${currentBinding}) var ${samp.name}: sampler;\n`;
                    passResources.samplers.push({
                        ...samp,
                        binding: currentBinding,
                        group: 0
                    });
                }
            });
            wgsl += '\n';

            // Append pass code
            wgsl += `// --- 通道 ${pass.index} ---\n`;

            // Remove //! directives and preprocess
            let processedPassCode = pass.code.replace(/\/\/!.*\n/g, '');
            processedPassCode = this._preprocessPassCode(processedPassCode, pass.index);

            // Set workgroup size
            const numThreads = pass.numThreads || [1, 1, 1];

            // Remove existing @compute or @workgroup_size attributes
            processedPassCode = processedPassCode.replace(/@compute\s*@workgroup_size\([^)]+\)\s*/g, '');

            // Standardize entry point name
            const passFunctionSignatureRegex = new RegExp(`fn Pass${pass.index}`);
            processedPassCode = processedPassCode.replace(
                passFunctionSignatureRegex,
                `fn main_cs `
            );

            // Prepend attributes
            processedPassCode = `@compute @workgroup_size(${numThreads[0]}, ${numThreads[1]}, ${numThreads[2]}) ${processedPassCode}`;

            wgsl += processedPassCode;

            // Store generated module
            generatedModules.push({
                wgslCode: wgsl.replace(/\r\n/g, '\n'),
                passIndex: pass.index,
                resources: passResources
            });
        });

        return generatedModules;
    }
}

// src/runtime/UniformBinder.js

/**
 * @fileoverview
 * - EN: Handles dynamic updates of uniform buffers.
 *   This class provides a simple API for changing uniform values at runtime.
 * - TW: 處理統一緩衝區的動態更新。
 *   此類別提供一個簡單的 API，用於在運行時更改統一值。
 */

let GPUDevice;

/**
 * - EN: In a Node.js environment, native WebGPU objects don't exist.
 *   We check for their existence on the global scope. If they don't exist,
 *   `GPUDevice` will remain `undefined`, which is safe for the CLI code path
 *   as it doesn't instantiate or use any GPU-related objects.
 * - TW: 在 Node.js 環境中，原生 WebGPU 物件不存在。
 *   我們檢查它們是否在全域範圍內存在。如果不存在，
 *   `GPUDevice` 將保持 `undefined`，這對於 CLI 程式碼路徑是安全的，
 *   因為它不實例化或使用任何與 GPU 相關的物件。
 */
try {
    /**
     * - EN: This will only succeed in a browser-like environment with WebGPU support.
     * - TW: 這只會在支援 WebGPU 的瀏覽器環境中成功。
     */
    if (globalThis.GPUDevice) {
        GPUDevice = globalThis.GPUDevice;
    }
    /**
     * - EN: In Node.js or a non-WebGPU environment, this will remain undefined.
     * - TW: 在 Node.js 或非 WebGPU 環境中，這將保持未定義。
     */
} catch (e) {
    /**
     * - EN: Ignore any errors during this detection phase.
     * - TW: 在此檢測階段忽略任何錯誤。
     */
}


class UniformBinder {
    /**
     * @param {GPUDevice} [device]
     * - EN: The active WebGPU device.
     * - TW: 作用中的 WebGPU 裝置。
     * @param {import('./ResourceManager.js').ResourceManager} resourceManager
     * - EN: An instance of the resource manager.
     * - TW: 資源管理器的實例。
     */
    constructor(device, resourceManager) {
        this.device = device || new GPUDevice();
        /**
         * - EN: Use provided device or a mock device.
         * - TW: 使用提供的裝置或模擬裝置。
         */
        this.resourceManager = resourceManager;
    }

    /**
     * - EN: Dynamically updates the value of a single uniform in the shared uniform buffer.
     * - TW: 在共享統一緩衝區中動態更新單個統一的值。
     * @param {string} name
     * - EN: The name of the uniform to update (e.g., `Strength`).
     * - TW: 要更新的統一名稱 (例如：`Strength`)。
     * @param {number} value
     * - EN: The new numeric value for the uniform.
     * - TW: 統一的新數值。
     */
    updateUniform(name, value) {
        /**
         * - EN: Retrieve uniform metadata (buffer, offset, size) from the resource manager.
         * - TW: 從資源管理器獲取統一的元資料 (緩衝區、偏移量、大小)。
         */
        const uniformInfo = this.resourceManager.getUniform(name);
        if (!uniformInfo) {
            console.warn(`Uniform '${name}' not found. Cannot update. / 找不到統一 '${name}'。無法更新。`);
            return;
        }

        const {buffer, offset, size} = uniformInfo;

        /**
         * - EN: Create a temporary typed array with the new value.
         *   This implementation simplifies things, assuming all uniforms are 4-byte floats.
         *   A more robust solution would check the parameter type from the IR.
         * - TW: 使用新值建立一個臨時的類型化陣列。
         *   此實作簡化了事情，假設所有統一都是 4 位元組浮點數。
         *   更穩健的解決方案將檢查 IR 中的參數類型。
         */
        const data = new Float32Array([value]);

        if (data.byteLength > size) {
            console.error(`Data size mismatch for uniform '${name}'. Expected ${size}, but got ${data.byteLength}. / 統一 '${name}' 的資料大小不匹配。預期為 ${size}，但得到 ${data.byteLength}。`);
            return;
        }

        /**
         * - EN: Write the data to the correct position in the GPU buffer.
         * - TW: 將資料寫入 GPU 緩衝區中的正確位置。
         */
        this.device.queue.writeBuffer(
            buffer,
            /**
             * - EN: Destination buffer.
             * - TW: 目標緩衝區。
             */
            offset,
            /**
             * - EN: Byte offset to start writing from.
             * - TW: 開始寫入的位元組偏移量。
             */
            data,
            /**
             * - EN: Source data.
             * - TW: 來源資料。
             */
            0,
            /**
             * - EN: Offset within the source data.
             * - TW: 來源資料中的偏移量。
             */
            size
            /**
             * - EN: Number of bytes to write.
             * - TW: 要寫入的位元組數。
             */
        );
    }
}

// src/runtime/WGFXRuntime.js


class WGFXRuntime {
    /**
     * @param {GPUDevice} device
     * - EN: The active WebGPU device.
     * - TW: 作用中的 WebGPU 裝置。
     */
    constructor(device) {
        if (!device) {
            /**
             * - EN: WGFXRuntime requires a valid WebGPU device. No device provided.
             * - TW: WGFXRuntime 需要一個有效的 WebGPU 裝置。未提供裝置。
             */
            throw new Error("WGFXRuntime requires a valid WebGPU device. No device provided.");
        }
        this.device = device;

        /**
         * - EN: Instantiate all necessary sub-modules.
         * - TW: 實例化所有必要的子模組。
         */
        // this.parser = new ShaderParser(); // No longer needed
        this.resourceManager = new ResourceManager(this.device);
        this.pipelineManager = new PipelineManager(this.device, this.resourceManager);
        this.wgslCodeGenerator = new WGSLCodeGenerator();
        this.uniformBinder = new UniformBinder(this.device, this.resourceManager);

        /**
         * - EN: Intermediate representation of the currently compiled shader.
         * - TW: 當前編譯著色器的中介表示。
         * @type {import('./ShaderParser.js').WGFXShaderInfo | null}
         */
        this.shaderInfo = null;
    }

    /**
     * - EN: Compiles a WGFX effect from a code string. This is the main entry point for setting up a new effect.
     *   The process involves parsing, code generation, resource allocation, and pipeline creation.
     * - TW: 從程式碼字串編譯 WGFX 效果。這是設定新效果的主要入口點。
     *   該過程涉及解析、程式碼生成、資源分配和管線建立。
     * @param {string} effectCode
     * - EN: The string containing the entire WGFX effect code.
     * - TW: 包含整個 WGFX 效果程式碼的字串。
     * @returns {Promise<void>}
     * - EN: A Promise that resolves when compilation is complete.
     * - TW: 編譯完成時解析的 Promise。
     */
    async compile(effectCode, externalResources = {}) {
        // FIXME: This is a temporary solution to pass external resources.
        // A more robust solution would be to have a dedicated method to set resources.
        /**
         * - EN: Starting effect compilation.
         * - TW: 開始效果編譯。
         */
        console.log("WGFXRuntime: Starting effect compilation.");
        /**
         * - EN: 1. Parse the FX file to get the Intermediate Representation (IR).
         * - TW: 1. 解析 FX 檔案以獲取中介表示 (IR)。
         */
        this.shaderInfo = peg$parse(effectCode);
        /**
         * - EN: ShaderInfo (IR) parsed.
         * - TW: 已解析 ShaderInfo (IR)。
         */
        console.log("WGFXRuntime: ShaderInfo (IR) parsed:", this.shaderInfo);
        /**
         * - EN: 2. Generate a single WGSL shader module from the IR.
         * - TW: 2. 從 IR 生成單個 WGSL 著色器模組。
         */
        const generatedModules = this.wgslCodeGenerator.generate(this.shaderInfo);
        // if (this.parser.debug) {
        //     /**
        //      * - EN: Old debug check removed
        //      * - TW: 舊的調試檢查已移除
        //      */
        //     console.log("WGFXRuntime: Generated WGSL module:", generatedModules);
        // }

        /**
         * - EN: 3. Initialize all GPU resources (textures, samplers, buffers) based on the IR.
         * - TW: 3. 根據 IR 初始化所有 GPU 資源 (紋理、取樣器、緩衝區)。
         */
        this.resourceManager.initialize(this.shaderInfo, externalResources);
        /**
         * - EN: Resources initialized.
         * - TW: 資源已初始化。
         */
        console.log("WGFXRuntime: Resources initialized.");
        /**
         * - EN: 4. Create compute pipelines for each pass.
         * - TW: 4. 為每個通道建立計算管線。
         */
        await this.pipelineManager.createPipelines(this.shaderInfo, generatedModules);
        /**
         * - EN: Pipelines created.
         * - TW: 管線已建立。
         */
        console.log("WGFXRuntime: Pipelines created.");
        /**
         * - EN: Compilation complete.
         * - TW: 編譯完成。
         */
        console.log("WGFXRuntime: Compilation complete.");
    }

    /**
     * - EN: Encodes commands to dispatch a specific compute pass.
     * - TW: 編碼調度特定計算通道的命令。
     * @param {string} passName
     * - EN: The name of the pass to dispatch (e.g., `PASS_1`).
     * - TW: 要調度的通道名稱 (例如：`PASS_1`)。
     * @param {GPUCommandEncoder} commandEncoder
     * - EN: The command encoder for the current frame.
     * - TW: 當前幀的命令編碼器。
     */
    dispatchPass(passName, commandEncoder) {
        if (!this.shaderInfo) {
            /**
             * - EN: Effect not compiled. Call compile() first.
             * - TW: 效果未編譯。請先呼叫 compile()。
             */
            throw new Error("Effect not compiled. Call compile() first.");
        }

        /**
         * - EN: Look up the corresponding pass information from the IR.
         * - TW: 從 IR 中查找對應的通道資訊。
         */
        const passIndex = parseInt(passName.split('_')[1], 10);
        const passInfo = this.shaderInfo.passes.find(p => p.index === passIndex);
        if (!passInfo) {
            /**
             * - EN: Pass `passName` not found in shader information.
             * - TW: 在著色器資訊中找不到通道 `passName`。
             */
            throw new Error(`Pass "${passName}" not found in shader information.`);
        }

        /**
         * - EN: Delegate the actual dispatch logic to the pipeline manager.
         * - TW: 將實際的調度邏輯委託給管線管理器。
         */
        this.pipelineManager.dispatchPass(passInfo, commandEncoder);
    }

    /**
     * - EN: Updates the value of a uniform parameter in the GPU buffer.
     * - TW: 更新 GPU 緩衝區中 uniform 參數的值。
     * @param {string} name
     * - EN: The name of the uniform to update.
     * - TW: 要更新的 uniform 名稱。
     * @param {number} value
     * - EN: The new value for the uniform.
     * - TW: uniform 的新值。
     */
    updateUniform(name, value) {
        if (!this.shaderInfo) {
            /**
             * - EN: Effect not compiled. Call compile() first.
             * - TW: 效果未編譯。請先呼叫 compile()。
             */
            throw new Error("Effect not compiled. Call compile() first.");
        }
        this.uniformBinder.updateUniform(name, value);
    }

    /**
     * - EN: Gets the GPUTextureView of the final output texture, usually named 'OUTPUT'.
     * - TW: 獲取最終輸出紋理的 GPUTextureView，通常命名為 'OUTPUT'。
     * @returns {GPUTextureView}
     * - EN: The texture view of the final output.
     * - TW: 最終輸出的紋理視圖。
     */
    getOutput() {
        const outputTexture = this.resourceManager.getTexture('OUTPUT');
        if (!outputTexture) {
            /**
             * - EN: Output texture `OUTPUT` not found in ResourceManager. Ensure it is correctly defined or managed.
             * - TW: 在 ResourceManager 中找不到輸出紋理 `OUTPUT`。請確保已正確定義或管理。
             */
            throw new Error("Output texture 'OUTPUT' not found in ResourceManager. Ensure it is correctly defined or managed.");
        }
        return outputTexture.createView();
    }

    /**
     * - EN: Utility function to get raw GPU resources.
     * - TW: 獲取原始 GPU 資源的實用函數。
     * @param {string} name
     * - EN: The name of the resource.
     * - TW: 資源的名稱。
     * @returns {GPUTexture | GPUSampler | GPUBuffer | undefined}
     * - EN: The underlying GPU resource.
     * - TW: 底層 GPU 資源。
     */
    getResource(name) {
        return this.resourceManager.getTexture(name)
            || this.resourceManager.getSampler(name)
            || this.resourceManager.getUniform(name)?.buffer;
    }
}

// src/index.js


/**
 * - EN: Singleton instance of WGFXRuntime.
 * - TW: WGFXRuntime 的單例實例。
 * @type {WGFXRuntime | null}
 */
let runtimeInstance = null;

/**
 * - EN: Initializes the runtime (if needed) and compiles the WGFX effect.
 *   This function must be called before any other API functions.
 * - TW: 初始化運行時 (如果需要) 並編譯 WGFX 效果。
 *   必須在任何其他 API 函數之前呼叫此函數。
 * @param {string} effectCode
 * - EN: The string containing the entire WGFX effect code.
 * - TW: 包含整個 WGFX 效果程式碼的字串。
 * @param {GPUDevice} device
 * - EN: The active WebGPU device.
 * - TW: 作用中的 WebGPU 裝置。
 * @returns {Promise<void>}
 * - EN: A Promise that resolves when compilation is complete.
 * - TW: 編譯完成時解析的 Promise。
 */
async function compile(effectCode, device, externalResources = {}) {
    runtimeInstance = new WGFXRuntime(device);
    await runtimeInstance.compile(effectCode, externalResources);
    return runtimeInstance.shaderInfo;
}

/**
 * - EN: Encodes commands to dispatch a specific compute pass in the compiled effect.
 * - TW: 編碼調度已編譯效果中特定計算通道的命令。
 * @param {string} passName
 * - EN: The name of the pass to dispatch (e.g., 'PASS_1').
 * - TW: 要調度的通道名稱 (例如：'PASS_1')。
 * @param {GPUCommandEncoder} commandEncoder
 * - EN: The command encoder for the current frame.
 * - TW: 當前幀的命令編碼器。
 */
function dispatchPass(passName, commandEncoder) {
    if (!runtimeInstance) {
        throw new Error("WGFX runtime not initialized. Call compile() first. / WGFX 運行時未初始化。請先呼叫 compile()。");
    }
    runtimeInstance.dispatchPass(passName, commandEncoder);
}

/**
 * - EN: Updates the value of a single uniform parameter.
 * - TW: 更新單個統一參數的值。
 * @param {string} name
 * - EN: The name of the uniform to update.
 * - TW: 要更新的統一名稱。
 * @param {number} value
 * - EN: The new numeric value for the uniform.
 * - TW: 統一的新數值。
 */
function updateUniform(name, value) {
    if (!runtimeInstance) {
        throw new Error("WGFX runtime not initialized. Call compile() first. / WGFX 運行時未初始化。請先呼叫 compile()。");
    }
    runtimeInstance.updateUniform(name, value);
}

/**
 * - EN: Gets the GPUTextureView of the final output texture.
 *   By convention, this is the texture named 'OUTPUT' in the WGFX file.
 * - TW: 獲取最終輸出紋理的 GPUTextureView。
 *   按照慣例，這是 WGFX 檔案中名為 'OUTPUT' 的紋理。
 * @returns {GPUTextureView}
 * - EN: The texture view of the final output.
 * - TW: 最終輸出的紋理視圖。
 */
function getOutput() {
    if (!runtimeInstance) {
        throw new Error("WGFX runtime not initialized. Call compile() first. / WGFX 運行時未初始化。請先呼叫 compile()。");
    }
    return runtimeInstance.getOutput();
}

exports.compile = compile;
exports.dispatchPass = dispatchPass;
exports.getOutput = getOutput;
exports.updateUniform = updateUniform;
