'use strict';

// @generated by Peggy 5.0.6.
//
// https://peggyjs.org/


class peg$SyntaxError extends SyntaxError {
    constructor(message, expected, found, location) {
        super(message);
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";
    }

    static buildMessage(expected, found) {
        function hex(ch) {
            return ch.codePointAt(0).toString(16).toUpperCase();
        }

        const nonPrintable = Object.prototype.hasOwnProperty.call(RegExp.prototype, "unicode")
            ? new RegExp("[\\p{C}\\p{Mn}\\p{Mc}]", "gu")
            : null;

        function unicodeEscape(s) {
            if (nonPrintable) {
                return s.replace(nonPrintable, ch => "\\u{" + hex(ch) + "}");
            }
            return s;
        }

        function literalEscape(s) {
            return unicodeEscape(s
                .replace(/\\/g, "\\\\")
                .replace(/"/g, "\\\"")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g, ch => "\\x0" + hex(ch))
                .replace(/[\x10-\x1F\x7F-\x9F]/g, ch => "\\x" + hex(ch)));
        }

        function classEscape(s) {
            return unicodeEscape(s
                .replace(/\\/g, "\\\\")
                .replace(/\]/g, "\\]")
                .replace(/\^/g, "\\^")
                .replace(/-/g, "\\-")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g, ch => "\\x0" + hex(ch))
                .replace(/[\x10-\x1F\x7F-\x9F]/g, ch => "\\x" + hex(ch)));
        }

        const DESCRIBE_EXPECTATION_FNS = {
            literal(expectation) {
                return "\"" + literalEscape(expectation.text) + "\"";
            },

            class(expectation) {
                const escapedParts = expectation.parts.map(
                    part => (Array.isArray(part)
                        ? classEscape(part[0]) + "-" + classEscape(part[1])
                        : classEscape(part))
                );

                return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]" + (expectation.unicode ? "u" : "");
            },

            any() {
                return "any character";
            },

            end() {
                return "end of input";
            },

            other(expectation) {
                return expectation.description;
            },
        };

        function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }

        function describeExpected(expected) {
            const descriptions = expected.map(describeExpectation);
            descriptions.sort();

            if (descriptions.length > 0) {
                let j = 1;
                for (let i = 1; i < descriptions.length; i++) {
                    if (descriptions[i - 1] !== descriptions[i]) {
                        descriptions[j] = descriptions[i];
                        j++;
                    }
                }
                descriptions.length = j;
            }

            switch (descriptions.length) {
                case 1:
                    return descriptions[0];

                case 2:
                    return descriptions[0] + " or " + descriptions[1];

                default:
                    return descriptions.slice(0, -1).join(", ")
                        + ", or "
                        + descriptions[descriptions.length - 1];
            }
        }

        function describeFound(found) {
            return found ? "\"" + literalEscape(found) + "\"" : "end of input";
        }

        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    }

    format(sources) {
        let str = "Error: " + this.message;
        if (this.location) {
            let src = null;
            const st = sources.find(s => s.source === this.location.source);
            if (st) {
                src = st.text.split(/\r\n|\n|\r/g);
            }
            const s = this.location.start;
            const offset_s = (this.location.source && (typeof this.location.source.offset === "function"))
                ? this.location.source.offset(s)
                : s;
            const loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
            if (src) {
                const e = this.location.end;
                const filler = "".padEnd(offset_s.line.toString().length, " ");
                const line = src[s.line - 1];
                const last = s.line === e.line ? e.column : line.length + 1;
                const hatLen = (last - s.column) || 1;
                str += "\n --> " + loc + "\n"
                    + filler + " |\n"
                    + offset_s.line + " | " + line + "\n"
                    + filler + " | " + "".padEnd(s.column - 1, " ")
                    + "".padEnd(hatLen, "^");
            } else {
                str += "\n at " + loc;
            }
        }
        return str;
    }
}

function peg$parse(input, options) {
    options = options !== undefined ? options : {};

    const peg$FAILED = {};
    const peg$source = options.grammarSource;

    const peg$startRuleFunctions = {
        start: peg$parsestart,
    };
    let peg$startRuleFunction = peg$parsestart;

    const peg$c0 = "\n";
    const peg$c1 = "//!";

    const peg$r0 = /^[^\n]/;
    const peg$r1 = /^[a-zA-Z0-9_]/;
    const peg$r2 = /^[ \t]/;

    const peg$e0 = peg$literalExpectation("\n", false);
    const peg$e1 = peg$literalExpectation("//!", false);
    const peg$e2 = peg$classExpectation(["\n"], true, false, false);
    const peg$e3 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_"], false, false, false);
    const peg$e4 = peg$classExpectation([" ", "\t"], false, false, false);

    function peg$f0() {
        // Commit the last block if it was a PASS and had accumulated code.
        // 如果最後一個區塊是 PASS 並且有累積的程式碼，則提交它。
        if (currentBlock === 'PASS' && passCodeBuffer.length > 0) {
            currentData.code = passCodeBuffer.join('\n');
        }
        // Commit any remaining current block data.
        // 提交任何剩餘的當前區塊資料。
        if (currentData) commitBlock(currentBlock, currentData);
        return shaderInfo;
    }

    function peg$f1() {
        return {type: "empty"};
    }

    function peg$f2(name, value) {
        const directive = name.toUpperCase();
        const val = value.trim();

        // Handle the 'END' directive, which explicitly closes the current block.
        // 處理 'END' 指令，它會明確關閉當前區塊。
        if (directive === 'END') {
            // If a PASS block was active, commit its accumulated code.
            // 如果 PASS 區塊處於活動狀態，則提交其累積的程式碼。
            if (currentBlock === 'PASS' && passCodeBuffer.length > 0) {
                currentData.code = passCodeBuffer.join('\n');
                passCodeBuffer = [];
            }
            // Commit any remaining current block data before ending.
            // 在結束前提交任何剩餘的當前區塊資料。
            if (currentData) {
                commitBlock(currentBlock, currentData);
            }
            currentBlock = null;
            currentData = null;
            return {type: "directive", directive: "END"};
        }

        // Check for block-starting directives.
        // 檢查區塊起始指令。
        if (["PARAMETER", "TEXTURE", "SAMPLER", "COMMON", "PASS", "VERSION", "SORT_NAME", "USE", "CAPABILITY"].includes(directive)) {
            // If we were in a PASS block, commit its code first before starting a new block.
            // 如果我們在 PASS 區塊中，則在開始新區塊之前先提交其程式碼。
            if (currentBlock === 'PASS' && passCodeBuffer.length > 0) {
                currentData.code = passCodeBuffer.join('\n');
                passCodeBuffer = [];
            }
            // Commit the data of the previous block.
            // 提交前一個區塊的資料。
            if (currentData) {
                commitBlock(currentBlock, currentData);
            }

            // Start a new block based on the directive.
            // 根據指令開始一個新區塊。
            if (["PARAMETER", "TEXTURE", "SAMPLER", "COMMON", "PASS"].includes(directive)) {
                currentBlock = directive;
                currentData = {id: val, lines: []}; // Initialize currentData for the new block.
                if (directive === 'PASS') currentData.index = parseInt(val, 10); // Special handling for PASS index.
            } else { // Global directives (VERSION, SORT_NAME, USE, CAPABILITY) are self-contained and don't start a multi-line block.
                currentBlock = null;
                currentData = null;
                commitBlock(directive, {id: val}); // Commit immediately as they are single-line directives.
            }
        } else { // This is a sub-directive within an active block.
            // If there's no active block, this sub-directive is out of place.
            // 如果沒有活動區塊，則此子指令放置不當。
            if (!currentData) throw new Error(`Directive //! ${directive} cannot be used here / 指令 //! ${directive} 不能在此處使用`);
            parseSubDirective(currentData, directive, val); // Parse the sub-directive.
        }
        return {type: "directive", directive: directive, value: val};
    }

    function peg$f3(text) {
        const lineStr = text.join("");
        const trimmedLine = lineStr.trim();

        // Special handling for resource declarations in TEXTURE, SAMPLER, PARAMETER blocks.
        // 對於 TEXTURE, SAMPLER, PARAMETER 區塊中的資源宣告進行特殊處理。
        if (currentBlock === 'TEXTURE' || currentBlock === 'SAMPLER' || currentBlock === 'PARAMETER') {
            const match = trimmedLine.match(/var\s+([a-zA-Z0-9_]+)\s*:/); // Regex to find variable declaration.
            if (match) {
                currentData.isTemplate = true; // Mark as a template for resource creation.
                const name = match[1]; // Extract the resource name.
                const newResource = {...currentData, name: name, id: name}; // Create a new resource object.
                delete newResource.lines; // These are specific to COMMON blocks.
                delete newResource.isTemplate;

                // Push the new resource to the appropriate shaderInfo array.
                // 將新資源推送到相應的 shaderInfo 陣列中。
                if (currentBlock === 'TEXTURE') {
                    shaderInfo.textures.push(newResource);
                } else if (currentBlock === 'SAMPLER') {
                    shaderInfo.samplers.push(newResource);
                } else if (currentBlock === 'PARAMETER') {
                    shaderInfo.parameters.push(newResource);
                }
                return {type: "code", text: lineStr};
            }
        }

        // Accumulate code lines for COMMON and PASS blocks.
        // 累積 COMMON 和 PASS 區塊的程式碼行。
        if (currentBlock === 'COMMON') {
            currentData.lines.push(lineStr);
        } else if (currentBlock === 'PASS') {
            passCodeBuffer.push(lineStr);
        }
        return {type: "code", text: lineStr};
    }

    let peg$currPos = options.peg$currPos | 0;
    const peg$posDetailsCache = [{line: 1, column: 1}];
    let peg$maxFailPos = peg$currPos;
    let peg$maxFailExpected = options.peg$maxFailExpected || [];
    let peg$silentFails = options.peg$silentFails | 0;

    let peg$result;

    if (options.startRule) {
        if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function peg$getUnicode(pos = peg$currPos) {
        const cp = input.codePointAt(pos);
        if (cp === undefined) {
            return "";
        }
        return String.fromCodePoint(cp);
    }

    function peg$literalExpectation(text, ignoreCase) {
        return {type: "literal", text, ignoreCase};
    }

    function peg$classExpectation(parts, inverted, ignoreCase, unicode) {
        return {type: "class", parts, inverted, ignoreCase, unicode};
    }

    function peg$endExpectation() {
        return {type: "end"};
    }

    function peg$computePosDetails(pos) {
        let details = peg$posDetailsCache[pos];
        let p;

        if (details) {
            return details;
        } else {
            if (pos >= peg$posDetailsCache.length) {
                p = peg$posDetailsCache.length - 1;
            } else {
                p = pos;
                while (!peg$posDetailsCache[--p]) {
                }
            }

            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column,
            };

            while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                } else {
                    details.column++;
                }

                p++;
            }

            peg$posDetailsCache[pos] = details;

            return details;
        }
    }

    function peg$computeLocation(startPos, endPos, offset) {
        const startPosDetails = peg$computePosDetails(startPos);
        const endPosDetails = peg$computePosDetails(endPos);

        const res = {
            source: peg$source,
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column,
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column,
            },
        };
        return res;
    }

    function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
            return;
        }

        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
    }

    function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(
            peg$SyntaxError.buildMessage(expected, found),
            expected,
            found,
            location
        );
    }

    function peg$parsestart() {
        let s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseline();
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseline();
        }
        s1 = peg$f0();
        s0 = s1;

        return s0;
    }

    function peg$parseline() {
        let s0, s1;

        s0 = peg$parsedirective_line();
        if (s0 === peg$FAILED) {
            s0 = peg$parsecode_line();
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 10) {
                    s1 = peg$c0;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e0);
                    }
                }
                if (s1 !== peg$FAILED) {
                    s1 = peg$f1();
                }
                s0 = s1;
            }
        }

        return s0;
    }

    function peg$parsedirective_line() {
        let s0, s1, s3, s5;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c1) {
            s1 = peg$c1;
            peg$currPos += 3;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e1);
            }
        }
        if (s1 !== peg$FAILED) {
            peg$parse_();
            s3 = peg$parseidentifier();
            if (s3 !== peg$FAILED) {
                peg$parse_();
                s5 = peg$parserest_of_line();
                s0 = peg$f2(s3, s5);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }

        return s0;
    }

    function peg$parsecode_line() {
        let s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = input.charAt(peg$currPos);
        if (peg$r0.test(s2)) {
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e2);
            }
        }
        if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = input.charAt(peg$currPos);
                if (peg$r0.test(s2)) {
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e2);
                    }
                }
            }
        } else {
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 10) {
                s2 = peg$c0;
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                }
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            s0 = peg$f3(s1);
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }

        return s0;
    }

    function peg$parseidentifier() {
        let s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = input.charAt(peg$currPos);
        if (peg$r1.test(s2)) {
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e3);
            }
        }
        if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = input.charAt(peg$currPos);
                if (peg$r1.test(s2)) {
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                    }
                }
            }
        } else {
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
        } else {
            s0 = s1;
        }

        return s0;
    }

    function peg$parserest_of_line() {
        let s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = input.charAt(peg$currPos);
        if (peg$r0.test(s2)) {
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e2);
            }
        }
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = input.charAt(peg$currPos);
            if (peg$r0.test(s2)) {
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                }
            }
        }
        s0 = input.substring(s0, peg$currPos);

        return s0;
    }

    function peg$parse_() {
        let s0, s1;

        s0 = [];
        s1 = input.charAt(peg$currPos);
        if (peg$r2.test(s1)) {
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e4);
            }
        }
        while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = input.charAt(peg$currPos);
            if (peg$r2.test(s1)) {
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e4);
                }
            }
        }

        return s0;
    }


    // Initialize the Intermediate Representation (IR) structure.
    // 初始化 IR 結構
    const shaderInfo = {
        metadata: {use: {}, capability: {}},
        parameters: [],
        textures: [],
        samplers: [],
        passes: [],
        commonCode: ''
    };

    // Tracks the currently active block type (e.g., 'PARAMETER', 'TEXTURE', 'PASS').
    // 追蹤當前活動的區塊類型 (例如：'PARAMETER', 'TEXTURE', 'PASS')。
    let currentBlock = null;
    // Stores data for the current block being parsed.
    // 儲存當前正在解析的區塊資料。
    let currentData = null;
    // Buffer to accumulate code lines within a 'PASS' block.
    // 用於在 'PASS' 區塊內累積程式碼行的緩衝區。
    let passCodeBuffer = [];

    /**
     * Commits the parsed data of a block to the main shaderInfo structure.
     * 將解析後的區塊資料提交到主要的 shaderInfo 結構中。
     * @param {string} blockType - The type of the block (e.g., 'PARAMETER', 'COMMON').
     * @param {object} data - The parsed data for the block.
     */
    function commitBlock(blockType, data) {
        if (!blockType || !data || data.isTemplate) {
            currentData = null;
            return;
        }
        switch (blockType) {
            case 'PARAMETER':
                shaderInfo.parameters.push(data);
                break;
            case 'COMMON':
                shaderInfo.commonCode = data.lines.join('\n');
                break;
            case 'TEXTURE':
                shaderInfo.textures.push(data);
                break;
            case 'SAMPLER':
                shaderInfo.samplers.push(data);
                break;
            case 'PASS':
                shaderInfo.passes.push(data);
                break;
            case 'VERSION':
                shaderInfo.metadata.version = parseInt(data.id, 10);
                break;
            case 'SORT_NAME':
                shaderInfo.metadata.sortName = data.id;
                break;
            case 'USE':
                data.id.split(',').forEach(f => shaderInfo.metadata.use[f.trim().toUpperCase()] = true);
                break;
            case 'CAPABILITY':
                data.id.split(',').forEach(f => shaderInfo.metadata.capability[f.trim().toUpperCase()] = true);
                break;
        }
        currentData = null;
    }

    /**
     * Parses sub-directives within a block (e.g., //! DEFAULT, //! MIN for PARAMETER).
     * 解析區塊內部的子指令 (例如 PARAMETER 的 //! DEFAULT, //! MIN)。
     * @param {object} data - The current block's data object to populate.
     * @param {string} directive - The name of the sub-directive.
     * @param {string} value - The value of the sub-directive.
     */
    function parseSubDirective(data, directive, value) {
        const key = directive.toLowerCase();
        switch (key) {
            case 'in':
            case 'out':
                data[key] = value.split(',').map(s => s.trim());
                break;
            case 'block_size':
                data.blockSize = value.split(',').map(Number);
                if (data.blockSize.length === 1) data.blockSize.push(data.blockSize[0]); // Handle single value for block_size
                break;
            case 'num_threads':
                data.numThreads = value.split(',').map(Number);
                while (data.numThreads.length < 3) data.numThreads.push(1); // Ensure 3 components for num_threads
                break;
            case 'default':
            case 'min':
            case 'max':
            case 'step':
                data[key] = parseFloat(value);
                break;
            case 'format':
                data[key] = value.toLowerCase() === 'r16g16b16a16_float' ? 'rgba16float' : value;
                break;
            default:
                data[key] = value;
        }
    }

    peg$result = peg$startRuleFunction();

    const peg$success = (peg$result !== peg$FAILED && peg$currPos === input.length);

    function peg$throw() {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input.length ? peg$getUnicode(peg$maxFailPos) : null,
            peg$maxFailPos < input.length
                ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
                : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
    }

    if (options.peg$library) {
        return /** @type {any} */ ({
            peg$result,
            peg$currPos,
            peg$FAILED,
            peg$maxFailExpected,
            peg$maxFailPos,
            peg$success,
            peg$throw: peg$success ? undefined : peg$throw,
        });
    }
    if (peg$success) {
        return peg$result;
    } else {
        peg$throw();
    }
}

// src/runtime/ResourceManager.js

/**
 * @fileoverview
 * - EN: Manages the creation, storage, and retrieval of WebGPU resources.
 *   This class handles GPUTexture, GPUSampler, and GPUBuffer objects based on the shader IR,
 *   providing a central location to access these resources by name.
 * - TW: 管理 WebGPU 資源的建立、儲存和檢索。
 *   此類別根據著色器 IR 處理 GPUTexture、GPUSampler 和 GPUBuffer 物件，
 *   提供一個中心位置，可以按名稱存取這些資源。
 */

let GPUDevice$1, GPUTextureUsage, GPUBufferUsage;

/**
 * - EN: In a Node.js environment, native WebGPU objects don't exist.
 *   We check for their existence on the global scope. If they don't exist,
 *   they will remain `undefined`, which is safe for the CLI code path
 *   as it doesn't instantiate or use any GPU-related objects.
 * - TW: 在 Node.js 環境中，原生 WebGPU 物件不存在。
 *   我們檢查它們是否在全域範圍內存在。如果不存在，
 *   它們將保持 `undefined`，這對於 CLI 程式碼路徑是安全的，
 *   因為它不實例化或使用任何與 GPU 相關的物件。
 */
try {
    /**
     * - EN: This will only succeed in a browser-like environment with WebGPU support.
     * - TW: 這只會在支援 WebGPU 的瀏覽器環境中成功。
     */
    if (globalThis.GPUDevice) {
        GPUDevice$1 = globalThis.GPUDevice;
        GPUTextureUsage = globalThis.GPUTextureUsage;
        GPUBufferUsage = globalThis.GPUBufferUsage;
    }
    /**
     * - EN: In Node.js or a non-WebGPU environment, these will remain undefined.
     *   This is safe because the CLI path does not use this functionality.
     * - TW: 在 Node.js 或非 WebGPU 環境中，這些將保持未定義。
     *   這很安全，因為 CLI 路徑不使用此功能。
     */
} catch (e) {
    /**
     * - EN: Ignore any errors during this detection phase.
     *   The variables will simply remain undefined.
     * - TW: 在此檢測階段忽略任何錯誤。
     *   變數將簡單地保持未定義。
     */
}


/**
 * - EN: ResourceManager Implementation
 * - TW: 資源管理器實作
 */

class ResourceManager {
    /**
     * @param {GPUDevice} [device]
     * - EN: The active WebGPU device. If not provided, a mock device will be used.
     * - TW: 作用中的 WebGPU 裝置。如果未提供，將使用模擬裝置。
     */
    constructor(device) {
        /** @type {GPUDevice} */
        /**
         * - EN: Use provided device or a mock device.
         * - TW: 使用提供的裝置或模擬裝置。
         */
        this.device = device || new GPUDevice$1();
        /**
         * - EN: Stores GPUTexture objects, mapped by their unique names.
         * - TW: 儲存 GPUTexture 物件，按其唯一名稱映射。
         * @type {Map<string, import('./WebGPU-mock.js').GPUTexture>}
         */
        this.textures = new Map();
        /**
         * - EN: Stores GPUSampler objects, mapped by their unique names.
         * - TW: 儲存 GPUSampler 物件，按其唯一名稱映射。
         * @type {Map<string, import('./WebGPU-mock.js').GPUSampler>}
         */
        this.samplers = new Map();
        /**
         * - EN: Stores metadata for each uniform, including its offset and size within the main buffer.
         * - TW: 儲存每個 uniform 的元資料，包括其在主緩衝區中的偏移量和大小。
         * @type {Map<string, {buffer: import('./WebGPU-mock.js').GPUBuffer, offset: number, size: number}>}
         */
        this.uniforms = new Map();
        /**
         * - EN: A single GPU buffer used to store all uniform parameters.
         * - TW: 用於儲存所有 uniform 參數的單一 GPU 緩衝區。
         * @type {import('./WebGPU-mock.js').GPUBuffer}
         */
        this.uniformBuffer = null;
    }

    /**
     * - EN: Initializes all GPU resources based on the parsed shader IR.
     * - TW: 根據解析後的著色器 IR 初始化所有 GPU 資源。
     * @param {import('./ShaderParser.js').WGFXShaderInfo} shaderInfo
     * - EN: Parsed shader information from Parser.js.
     * - TW: 來自 Parser.js 的解析後著色器資訊。
     */
    /**
     * - EN: Initializes all GPU resources based on the parsed shader IR.
     * - TW: 根據解析後的著色器 IR 初始化所有 GPU 資源。
     * @param {import('./ShaderParser.js').WGFXShaderInfo} shaderInfo
     * - EN: Parsed shader information from Parser.js.
     * - TW: 來自 Parser.js 的解析後著色器資訊。
     */
    /**
     * - EN: Initializes all GPU resources based on the parsed shader IR.
     * - TW: 根據解析後的著色器 IR 初始化所有 GPU 資源。
     * @param {import('./ShaderParser.js').WGFXShaderInfo} shaderInfo
     * - EN: Parsed shader information from Parser.js.
     * - TW: 來自 Parser.js 的解析後著色器資訊。
     */
    initialize(shaderInfo, externalResources = {}) {
        const context = {};

        // 1. [優先] 載入外部定義的常數 (如 INPUT_WIDTH/HEIGHT)
        if (externalResources.defines) {
            Object.assign(context, externalResources.defines);
        }

        // 2. 建立外部紋理 (INPUT, OUTPUT 等)
        if (externalResources.textures) {
            for (const [name, descriptor] of Object.entries(externalResources.textures)) {
                this.createTexture(name, descriptor);
            }
        }

        // 3. [後備] 如果 defines 沒給尺寸，嘗試從剛剛建立的 INPUT 紋理反查
        if ((!context['INPUT_WIDTH'] || !context['INPUT_HEIGHT']) && this.textures.has('INPUT')) {
            const inputTexture = this.getTexture('INPUT');
            if (inputTexture) {
                if (!context['INPUT_WIDTH']) context['INPUT_WIDTH'] = inputTexture.width;
                if (!context['INPUT_HEIGHT']) context['INPUT_HEIGHT'] = inputTexture.height;
            }
        }

        // --- Safe Math Parser (CSP Compliant: No eval/new Function) ---
        // 實作一個簡單的遞迴下降解析器，支援 +, -, *, /, %, () 和小數
        const parseMathExpression = (str) => {
            let pos = 0;
            // 移除所有空白
            str = str.replace(/\s+/g, '');

            const peek = () => str[pos];
            const consume = () => str[pos++];

            const parseFactor = () => {
                if (peek() === '(') {
                    consume(); // 吃掉 '('
                    const result = parseExpr();
                    if (peek() !== ')') throw new Error("Expected ')'");
                    consume(); // 吃掉 ')'
                    return result;
                }

                // 解析數字 (含負號和小數點)
                let numStr = '';
                if (peek() === '-') {
                    numStr += consume();
                }
                while (pos < str.length && (/[0-9.]/).test(peek())) {
                    numStr += consume();
                }
                if (numStr === '') throw new Error(`Unexpected char: '${peek()}' at pos ${pos}`);
                return parseFloat(numStr);
            };

            const parseTerm = () => {
                let left = parseFactor();
                while (pos < str.length) {
                    const op = peek();
                    if (op === '*' || op === '/' || op === '%') {
                        consume();
                        const right = parseFactor();
                        if (op === '*') left *= right;
                        else if (op === '/') left /= right;
                        else if (op === '%') left %= right;
                    } else {
                        break;
                    }
                }
                return left;
            };

            const parseExpr = () => {
                let left = parseTerm();
                while (pos < str.length) {
                    const op = peek();
                    if (op === '+' || op === '-') {
                        consume();
                        const right = parseTerm();
                        if (op === '+') left += right;
                        else if (op === '-') left -= right;
                    } else {
                        break;
                    }
                }
                return left;
            };

            const result = parseExpr();
            return result;
        };

        const evaluate = (expr, ctx) => {
            if (typeof expr !== 'string') return expr;

            // 替換變數
            let evaluatedExpr = expr;
            for (const key in ctx) {
                const regex = new RegExp('\\b' + key + '\\b', 'g');
                evaluatedExpr = evaluatedExpr.replace(regex, ctx[key]);
            }

            try {
                // 如果替換後只是單純的數字字串，直接轉換 (最快)
                if (!isNaN(Number(evaluatedExpr))) {
                    return Math.ceil(Number(evaluatedExpr));
                }
                // 否則使用安全的解析器計算
                return Math.ceil(parseMathExpression(evaluatedExpr));
            } catch (e) {
                console.error("Evaluation failed. Context:", ctx);
                throw new Error(`Cannot evaluate expression: "${expr}". Resulted in: "${evaluatedExpr}". Error: ${e.message}`);
            }
        };

        /**
         * - EN: Create textures defined in the shader.
         * - TW: 建立著色器中定義的紋理。
         */
        shaderInfo.textures.forEach(tex => {
            if (this.textures.has(tex.name)) return; // Already created externally

            const width = evaluate(tex.width, context);
            const height = evaluate(tex.height, context);

            if (!width || !height) {
                throw new Error(`Could not determine size for texture ${tex.name}. Width or height expression is invalid.`);
            }

            const descriptor = {
                size: [width, height],
                format: tex.format?.toLowerCase() || 'rgba8unorm',
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
            };
            this.createTexture(tex.name, descriptor);
        });

        /**
         * - EN: Create samplers defined in the shader.
         * - TW: 建立著色器中定義的取樣器。
         */
        shaderInfo.samplers.forEach(samp => {
            const descriptor = {
                magFilter: samp.filter === 'LINEAR' ? 'linear' : 'nearest',
                minFilter: samp.filter === 'LINEAR' ? 'linear' : 'nearest',
                addressModeU: samp.address === 'WRAP' ? 'repeat' : 'clamp-to-edge',
                addressModeV: samp.address === 'WRAP' ? 'repeat' : 'clamp-to-edge',
            };
            this.createSampler(samp.name, descriptor);
        });

        /**
         * - EN: Create a single uniform buffer to store all parameters.
         * - TW: 建立一個單一的 uniform 緩衝區來儲存所有參數。
         */
        if (shaderInfo.parameters.length > 0) {
            let totalSize = 0;
            shaderInfo.parameters.forEach(param => {
                const size = 4; // Assuming 4 bytes (f32/i32) for simplicity
                this.uniforms.set(param.name, {buffer: null, offset: totalSize, size});
                totalSize += size;
            });

            const alignedSize = Math.ceil(totalSize / 16) * 16;

            this.uniformBuffer = this.device.createBuffer({
                size: alignedSize,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });

            this.uniforms.forEach(u => u.buffer = this.uniformBuffer);
        }

        console.log("ResourceManager: Resources initialized.", {
            textures: [...this.textures.keys()],
            samplers: [...this.samplers.keys()],
            uniforms: [...this.uniforms.keys()],
            context: context
        });
    }
    /**
     * - EN: Creates or replaces a GPUTexture in the manager.
     * - TW: 在管理器中建立或替換 GPUTexture。
     * @param {string} name
     * - EN: The unique name of the texture.
     * - TW: 紋理的唯一名稱。
     * @param {GPUTextureDescriptor} descriptor
     * - EN: The descriptor for the texture.
     * - TW: 紋理描述符。
     * @returns {GPUTexture}
     * - EN: The created GPUTexture.
     * - TW: 建立的 GPUTexture。
     */
    createTexture(name, descriptor) {
        /**
         * - EN: If a texture with the same name exists, destroy the old one first.
         * - TW: 如果存在同名紋理，則先銷毀舊紋理。
         */
        if (this.textures.has(name)) {
            this.textures.get(name).destroy();
        }
        const texture = this.device.createTexture(descriptor);
        /**
         * - EN: Set label for debugging.
         * - TW: 設定標籤以進行調試。
         */
        texture.label = name;
        this.textures.set(name, texture);
        return texture;
    }

    /**
     * - EN: Retrieves a texture by its name.
     * - TW: 按名稱檢索紋理。
     * @param {string} name
     * - EN: The name of the texture.
     * - TW: 紋理的名稱。
     * @returns {GPUTexture | undefined}
     * - EN: The texture object or undefined if not found.
     * - TW: 紋理物件，如果找不到則為 undefined。
     */
    getTexture(name) {
        return this.textures.get(name);
    }

    /**
     * - EN: Creates a new GPUSampler.
     * - TW: 建立新的 GPUSampler。
     * @param {string} name
     * - EN: The unique name of the sampler.
     * - TW: 取樣器的唯一名稱。
     * @param {GPUSamplerDescriptor} descriptor
     * - EN: The descriptor for the sampler.
     * - TW: 取樣器描述符。
     * @returns {GPUSampler}
     * - EN: The created GPUSampler.
     * - TW: 建立的 GPUSampler。
     */
    createSampler(name, descriptor) {
        const sampler = this.device.createSampler(descriptor);
        this.samplers.set(name, sampler);
        return sampler;
    }

    /**
     * - EN: Uploads image data (ImageBitmap, VideoFrame, etc.) to a specified GPUTexture.
     * - TW: 將圖像資料 (ImageBitmap, VideoFrame 等) 上傳到指定的 GPUTexture。
     * @param {string} name - The name of the texture (e.g., 'INPUT').
     * @param {ImageBitmap | VideoFrame | HTMLCanvasElement} image - The source image data.
     */
    updateTextureFromImage(name, image) {
        const texture = this.getTexture(name);

        if (!texture) {
            throw new Error(`Texture '${name}' not found for update.`);
        }

        // Ensure the texture has COPY_DST usage, which is usually included for dynamic textures.
        // We assume 'INPUT' is correctly set up with the right dimensions/format during compile/external setup.

        if (texture.width !== image.width || texture.height !== image.height) {
            // In a real implementation, you might resize the texture or throw an error.
            // For simplicity, we assume the input size matches the texture size (e.g., INPUT is pre-sized).
            console.warn(`Input image size (${image.width}x${image.height}) does not match texture size (${texture.width}x${texture.height}).`);
        }

        this.device.queue.copyExternalImageToBufferOrTexture(
            { source: image },
            { texture: texture },
            [image.width, image.height]
        );
        console.log(`Texture '${name}' updated from image source.`);
    }

    /**
     * - EN: Retrieves a sampler by its name.
     * - TW: 按名稱檢索取樣器。
     * @param {string} name
     * - EN: The name of the sampler.
     * - TW: 取樣器的名稱。
     * @returns {GPUSampler | undefined}
     * - EN: The sampler object or undefined if not found.
     * - TW: 取樣器物件，如果找不到則為 undefined。
     */
    getSampler(name) {
        return this.samplers.get(name);
    }

    /**
     * - EN: Retrieves the single uniform buffer for all parameters.
     * - TW: 檢索所有參數的單一 uniform 緩衝區。
     * @returns {GPUBuffer | null} - EN: The uniform buffer object, or null if no parameters exist. - TW: 統一緩衝區物件，如果不存在參數則為 null。
     */
    getUniformBuffer() {
        return this.uniformBuffer;
    }

    /**
     * - EN: Retrieves metadata for a specific uniform.
     * - TW: 檢索特定 uniform 的元資料。
     * @param {string} name
     * - EN: The name of the uniform parameter.
     * - TW: uniform 參數的名稱。
     * @returns {{buffer: GPUBuffer, offset: number, size: number} | undefined}
     * - EN: Metadata for the uniform, or undefined if not found.
     * - TW: uniform 的元資料，如果找不到則為 undefined。
     */
    getUniform(name) {
        return this.uniforms.get(name);
    }

    /**
     * - EN: Destroys all managed GPU resources to prevent memory leaks.
     * - TW: 銷毀所有管理的 GPU 資源以防止記憶體洩漏。
     */
    dispose() {
        this.textures.forEach(texture => texture.destroy());
        /**
         * - EN: Destroy all GPU textures.
         * - TW: 銷毀所有 GPU 紋理。
         */
        this.uniforms.clear();
        /**
         * - EN: Clear uniform metadata.
         * - TW: 清除 uniform 元資料。
         */
        if (this.uniformBuffer) {
            this.uniformBuffer.destroy();
            /**
             * - EN: Destroy the uniform buffer.
             * - TW: 銷毀 uniform 緩衝區。
             */
        }
        this.textures.clear();
        /**
         * - EN: Clear the texture map.
         * - TW: 清除紋理映射。
         */
        this.samplers.clear();
        /**
         * - EN: Clear the sampler map.
         * - TW: 清除取樣器映射。
         */
        /**
         * - EN: All GPU resources destroyed.
         * - TW: 所有 GPU 資源已銷毀。
         */
        console.log("ResourceManager: All GPU resources destroyed.");
    }
}

// src/runtime/PipelineManager.js

/**
 * - EN: Manages the creation and scheduling of WebGPU compute pipelines.
 *   This class receives shader IR and WGSL code to build the required GPU state,
 *   including pipeline layouts, pipelines, and bind groups.
 * - TW: 管理 WebGPU 計算管線的建立和調度。
 *   此類別接收著色器 IR 和 WGSL 程式碼,以建立執行所需的 GPU 狀態,
 *   包括管線佈局、管線和綁定組。
 */
class PipelineManager {
    /**
     * - EN: Constructs a new PipelineManager instance.
     * - TW: 建構一個新的 PipelineManager 實例。
     *
     * @param {GPUDevice} device
     * - EN: The active WebGPU device.
     * - TW: 作用中的 WebGPU 裝置。
     *
     * @param {import('./ResourceManager.js').ResourceManager} resourceManager
     * - EN: An instance of the resource manager.
     * - TW: 資源管理器的實例。
     */
    constructor(device, resourceManager) {
        this.device = device;
        this.resourceManager = resourceManager;

        /**
         * - EN: A map storing pipeline components and metadata for each pass, indexed by pass index.
         * - TW: 儲存每個通道的管線組件和中繼資料的映射表,以通道索引為鍵。
         *
         * @type {Map<number, {
         *   shaderModule: GPUShaderModule,
         *   bindGroupLayout: GPUBindGroupLayout,
         *   pipelineLayout: GPUPipelineLayout,
         *   computePipeline: GPUComputePipeline,
         *   resources: {
         *     textures: import('./Parser.js').WGFXTexture[],
         *     samplers: import('./Parser.js').WGFXSampler[],
         *     parameters: import('./Parser.js').WGFXParameter[]
         *   },
         *   passInfo: import('./Parser.js').WGFXPass
         * }>}
         */
        this.pipelines = new Map();
    }

    /**
     * - EN: Asynchronously creates compute pipelines for all passes defined in the shader IR.
     * - TW: 非同步建立著色器 IR 中定義的所有通道的計算管線。
     *
     * @param {import('./Parser.js').WGFXShaderInfo} shaderInfo
     * - EN: The parsed shader information (IR).
     * - TW: 解析後的著色器資訊 (IR)。
     *
     * @param {string} generatedModules
     * - EN: The complete, generated WGSL shader code.
     * - TW: 完整、生成的 WGSL 著色器程式碼。
     *
     * @returns {Promise<void>}
     * - EN: A promise that resolves when all pipelines are created.
     * - TW: 當所有管線建立完成時解析的 Promise。
     */
    async createPipelines(shaderInfo, generatedModules) {
        // EN: Clear any existing pipelines
        // TW: 清除任何現有的管線
        this.pipelines.clear();

        for (const module of generatedModules) {
            const pass = shaderInfo.passes.find(p => p.index === module.passIndex);
            if (!pass) {
                console.warn(`WGFXRuntime: Pass with index ${module.passIndex} not found in shaderInfo.`);
                continue;
            }

            // EN: 1. Create GPUShaderModule
            // TW: 1. 建立 GPUShaderModule
            const shaderModule = this.device.createShaderModule({
                code: module.wgslCode,
                label: `Pass ${module.passIndex} Shader Module`
            });

            // EN: 2. Create GPUBindGroupLayout
            // TW: 2. 建立 GPUBindGroupLayout
            const bindGroupLayoutEntries = [];

            // EN: Samplers
            // TW: 取樣器
            module.resources.samplers.forEach(samp => {
                bindGroupLayoutEntries.push({
                    binding: samp.binding,
                    visibility: GPUShaderStage.COMPUTE,
                    sampler: {type: 'filtering'}
                });
            });

            // EN: Uniforms (binding 1 if present)
            // TW: 統一變數 (如存在則使用綁定點 1)
            if (module.resources.parameters.length > 0) {
                bindGroupLayoutEntries.push({
                    binding: 1, // EN: Fixed binding for uniforms / TW: 統一變數的固定綁定點
                    visibility: GPUShaderStage.COMPUTE,
                    buffer: {type: 'uniform'}
                });
            }

            // EN: Textures
            // TW: 紋理
            module.resources.textures.forEach(tex => {
                bindGroupLayoutEntries.push({
                    binding: tex.binding,
                    visibility: GPUShaderStage.COMPUTE,
                    ...(tex.isStorage ? {
                        storageTexture: {
                            format: tex.format || 'rgba8unorm',
                            access: 'write-only'
                        }
                    } : {texture: {sampleType: 'float'}})
                });
            });

            const bindGroupLayout = this.device.createBindGroupLayout({
                entries: bindGroupLayoutEntries,
                label: `Pass ${module.passIndex} Bind Group Layout`
            });

            // EN: 3. Create GPUPipelineLayout
            // TW: 3. 建立 GPUPipelineLayout
            const pipelineLayout = this.device.createPipelineLayout({
                bindGroupLayouts: [bindGroupLayout],
                label: `Pass ${module.passIndex} Pipeline Layout`
            });

            // EN: 4. Create GPUComputePipeline
            // TW: 4. 建立 GPUComputePipeline
            const computePipeline = await this.device.createComputePipelineAsync({
                layout: pipelineLayout,
                compute: {
                    module: shaderModule,
                    // EN: Assuming 'main_cs' is the entry point for all compute shaders
                    // TW: 假定 'main_cs' 是所有計算著色器的進入點
                    entryPoint: 'main_cs',
                },
                label: `Pass ${module.passIndex} Compute Pipeline`
            });

            // EN: Store the pipeline components
            // TW: 儲存管線組件
            this.pipelines.set(module.passIndex, {
                shaderModule,
                bindGroupLayout,
                pipelineLayout,
                computePipeline,
                resources: module.resources, // EN: Store resources for bind group creation later / TW: 儲存資源供後續建立綁定組使用
                passInfo: pass // EN: Store original pass info for dispatching / TW: 儲存原始通道資訊供調度使用
            });
        }
    }

    /**
     * - EN: Encodes commands to dispatch a specific compute pass.
     * - TW: 編碼調度特定計算通道的命令。
     *
     * @param {import('./Parser.js').WGFXPass} passInfo
     * - EN: The IR object of the pass to be dispatched.
     * - TW: 要調度的通道的 IR 物件。
     *
     * @param {GPUCommandEncoder} commandEncoder
     * - EN: The command encoder for the current frame.
     * - TW: 當前幀的命令編碼器。
     *
     * @throws {Error}
     * - EN: If the pipeline for the given pass is not found or if required resources are missing.
     * - TW: 如果找不到給定通道的管線或缺少必要資源時拋出錯誤。
     */
    dispatchPass(passInfo, commandEncoder) {
        const storedPipeline = this.pipelines.get(passInfo.index);
        if (!storedPipeline) {
            throw new Error(`找不到通道 ${passInfo.index} 的管線。是否已編譯?`);
        }

        const {computePipeline, bindGroupLayout, resources, passInfo: originalPassInfo} = storedPipeline;

        const bindGroupEntries = [];

        // EN: Samplers
        // TW: 取樣器
        resources.samplers.forEach(samp => {
            const sampler = this.resourceManager.getSampler(samp.name);
            if (!sampler) {
                // EN: If 'sam' is a default sampler, it might not be in resourceManager if not explicitly defined in the shader.
                // For now, assume it's always available or created by resourceManager.
                // TW: 如果 'sam' 是預設取樣器,若未在著色器中明確定義,可能不在 resourceManager 中。
                // 目前假定它總是可用或由 resourceManager 建立。
                if (samp.name === 'sam') {
                    // EN: Create a default linear sampler if 'sam' is not found
                    // TW: 如果找不到 'sam',建立預設的線性取樣器
                    const defaultSampler = this.device.createSampler({
                        magFilter: 'linear',
                        minFilter: 'linear',
                    });
                    bindGroupEntries.push({binding: samp.binding, resource: defaultSampler});
                } else {
                    throw new Error(`Sampler ${samp.name} not found in ResourceManager.`);
                }
            } else {
                bindGroupEntries.push({binding: samp.binding, resource: sampler});
            }
        });

        // EN: Uniforms (binding 1 if present)
        // TW: 統一變數 (如存在則使用綁定點 1)
        if (resources.parameters.length > 0) {
            const uniformBuffer = this.resourceManager.getUniformBuffer();
            if (!uniformBuffer) {
                throw new Error("Uniform buffer not found in ResourceManager.");
            }
            bindGroupEntries.push({binding: 1, resource: {buffer: uniformBuffer}}); // EN: Fixed binding for uniforms / TW: 統一變數的固定綁定點
        }

        // EN: Textures
        // TW: 紋理
        resources.textures.forEach(tex => {
            const texture = this.resourceManager.getTexture(tex.name);
            if (!texture) {
                throw new Error(`Texture ${tex.name} not found in ResourceManager.`);
            }
            bindGroupEntries.push({binding: tex.binding, resource: texture.createView()});
        });

        const bindGroup = this.device.createBindGroup({
            layout: bindGroupLayout,
            entries: bindGroupEntries,
            label: `Pass ${passInfo.index} Bind Group`
        });

        // EN: Encode compute pass commands
        // TW: 編碼計算通道命令
        const passEncoder = commandEncoder.beginComputePass();
        passEncoder.setPipeline(computePipeline);
        passEncoder.setBindGroup(0, bindGroup);

        // EN: Calculate the number of workgroups to dispatch.
        // This is based on the size of the primary output texture and the workgroup size.
        // TW: 計算要調度的工作組數量。
        // 這基於主要輸出紋理的大小和工作組大小。
        const outputTextureName = originalPassInfo.out[0]; // EN: Assume the first output is the primary output for sizing / TW: 假定第一個輸出是主要輸出,用於確定大小
        const outputTexture = this.resourceManager.getTexture(outputTextureName);
        const workgroupSize = originalPassInfo.numThreads; // EN: e.g., [8, 8, 1] / TW: 例如,[8, 8, 1]

        const dispatchX = Math.ceil(outputTexture.width / workgroupSize[0]);
        const dispatchY = Math.ceil(outputTexture.height / workgroupSize[1]);

        passEncoder.dispatchWorkgroups(dispatchX, dispatchY, 1);
        passEncoder.end();
    }

    /**
     * - EN: Clears all stored GPU objects. Does not destroy them as they are managed by the device.
     * - TW: 清除所有儲存的 GPU 物件。不銷毀它們,因為它們由裝置管理。
     *
     * @returns {void}
     */
    dispose() {
        this.pipelines.clear();
        console.log("PipelineManager: All stored pipeline states have been cleared.");
    }
}

// src/runtime/WGSLCodeGenerator.js
/**
 * - EN: Assembles a complete WGSL shader module from WGFX IR objects.
 * This class does not translate HLSL to WGSL; based on user feedback,
 * it assumes each pass in the IR already contains valid WGSL code.
 * Responsibilities:
 *   1. Generate resource bindings (@group, @binding).
 *   2. Create a uniform buffer structure for parameters.
 *   3. Inject common code blocks.
 *   4. Wrap each pass's WGSL code into a properly attributed entry-point function.
 *
 * - TW: 從 WGFX IR 物件組裝完整的 WGSL 著色器模組。
 * 此類別不負責將 HLSL 轉換為 WGSL；根據使用者回饋，
 * 假設 IR 中每個 pass 的程式碼本身已為有效 WGSL。
 * 職責包括：
 *   1. 生成資源綁定（@group、@binding）。
 *   2. 建立參數用的 uniform buffer 結構。
 *   3. 注入通用程式碼區塊。
 *   4. 將每個 pass 的 WGSL 程式碼包裝成具正確屬性的入口函式。
 */

class WGSLCodeGenerator {
    /**
     * - EN: Constructs a new WGSLCodeGenerator instance.
     * - TW: 建構一個新的 WGSLCodeGenerator 實例。
     */
    constructor() {
        /**
         * - EN: No complex translation logic needed.
         * - TW: 不需要複雜的轉譯邏輯。
         */
    }

    /**
     * - EN: Preprocesses pass code to fix WGSL type errors and syntax issues.
     * Applies pass-specific transformations based on pass index.
     * - TW: 根據通道索引套用特定的轉換。
     * 預處理通道程式碼以修正 WGSL 型別錯誤和語法問題。
     *
     * @param {string} passCode
     * - EN: The raw WGSL code for the pass.
     * - TW: 通道的原始 WGSL 程式碼。
     * @param {number} passIndex
     * - EN: The index of the pass being processed.
     * - TW: 正在處理的通道索引。
     * @returns {string}
     * - EN: The processed WGSL code with fixes applied.
     * - TW: 套用修正後的處理過的 WGSL 程式碼。
     * @private
     */
    _preprocessPassCode(passCode, passIndex) {
        let processedCode = passCode;

        /**
         * - EN: Fix WGSL type error: vec2<u32> + f32
         * - TW: 修正 WGSL 型別錯誤: vec2<u32> + f32
         */
        processedCode = processedCode.replace(/\(gxy \+ 0\.5f\)/g, '(MF2(gxy) + 0.5f)');

        /**
         * - EN: Replace threadId.x with local_id.x
         * - TW: 將 threadId.x 替換為 local_id.x
         */
        processedCode = processedCode.replace(/threadId\.x/g, 'local_id.x');

        /**
         * - EN: Apply gxy fixes based on passIndex
         * - TW: 根據 passIndex 套用 gxy 修正
         */
        if (passIndex === 1) {
            /**
             * - EN: Pass1: Change bitshift to multiplication for WGSL compatibility
             * - TW: Pass1: 將位元移位改為乘法以符合 WGSL 相容性
             */
            processedCode = processedCode.replace(
                /let gxy = \(Rmp8x8\(local_id\.x\) << 1u\) \+ workgroup_id\.xy;/,
                'let gxy = (Rmp8x8(local_id.x) * 2u) + workgroup_id.xy;'
            );
        } else if (passIndex >= 2 && passIndex <= 7) {
            /**
             * - EN: Pass2-Pass7: Replace blockStart with workgroup_id calculation
             * - TW: Pass2-Pass7: 將 blockStart 替換為 workgroup_id 計算
             */
            processedCode = processedCode.replace(
                /let gxy: uint2\s*=\s*Rmp8x8\(local_id\.x\) \+ blockStart;/,
                'let gxy: uint2 = Rmp8x8(local_id.x) + workgroup_id.xy * 8u;'
            );
        } else if (passIndex === 8) {
            /**
             * - EN: Pass8: Adjust workgroup_id calculation for proper indexing
             * - TW: Pass8: 調整 workgroup_id 計算以正確索引
             */
            processedCode = processedCode.replace(
                /let gxy: uint2 = Rmp8x8\(local_id\.x\) \+ workgroup_id\.xy;/,
                'let gxy: uint2 = Rmp8x8(local_id.x) + workgroup_id.xy * 8u;'
            );
        }

        /**
         * - EN: Fix variable redeclarations within a pass for specific patterns.
         * This targets lines like 'var a1 = max(a1, MF4(0.0));' where the variable is already declared.
         * - TW: 這針對像 'var a1 = max(a1, MF4(0.0));' 這樣的行,其中變數已經被宣告
         * 修正通道內特定模式的變數重複宣告。
         */
        processedCode = processedCode.replace(
            /var\s+(a1|b1|c1|d1|e1|f1|g1|h1|i1|na1|nb1|nc1|nd1|ne1|nf1|ng1|nh1|ni1|na2|nb2|nc2|nd2|ne2|nf2|ng2|nh2|ni2|na3|nb3|nc3|nd3|ne3|nf3|ng3|nh3|ni3)\s+=\s+max\(\1,\s+MF4\(0\.0\)\);/g,
            '$1 = max($1, MF4(0.0));'
        );

        return processedCode;
    }

    /**
     * - EN: Assembles a final WGSL shader module from parsed shader information (IR).
     * Generates separate shader modules for each pass with appropriate resource bindings.
     * - TW: 為每個通道生成獨立的著色器模組,包含適當的資源綁定。
     * 從解析後的著色器資訊 (IR) 組裝一個最終的 WGSL 著色器模組。
     *
     * @param {import('./Parser.js').WGFXShaderInfo} shaderInfo
     * - EN: The parsed shader information (IR).
     * - TW: 解析後的著色器資訊 (IR)。
     * @returns {Array<{wgslCode: string, passIndex: number, resources: {textures: import('./Parser.js').WGFXTexture[], samplers: import('./Parser.js').WGFXSampler[], parameters: import('./Parser.js').WGFXParameter[]}}>}
     * - EN: Array of generated WGSL shader modules, one per pass, with associated resource metadata.
     * - TW: 生成的 WGSL 著色器模組陣列,每個通道一個模組,包含相關的資源中繼資料。
     */
    generate(shaderInfo) {
        const generatedModules = [];

        /**
         * - EN: Inject common code block. Replace 'type' with 'alias' for WGSL compatibility if present.
         * - TW: 注入通用程式碼區塊。如果存在,將 'type' 替換為 'alias' 才能符合 WGSL 相容性。
         */
        const commonCode = shaderInfo.commonCode
            ? `// --- 通用程式碼 ---\n${shaderInfo.commonCode}\n\n`
            : '';

        /**
         * - EN: Generate uniform buffer structure and binding (if any parameters exist)
         * - TW: 生成統一緩衝區結構和綁定 (如果有參數的話)
         */
        let uniformBufferCode = '';
        if (shaderInfo.parameters.length > 0) {
            uniformBufferCode += `struct Uniforms {\n`;
            shaderInfo.parameters.forEach(p => {
                const type = p.type === 'int' ? 'i32' : 'f32';
                uniformBufferCode += `    ${p.name}: ${type},\n`;
            });
            uniformBufferCode += `};\n`;
            /**
             * - EN: Uniforms always bound to group 0, binding 1 (binding 0 is reserved for 'sam' sampler)
             * - TW: Uniforms 始終綁定到 group 0, binding 1 (binding 0 保留給 'sam' 取樣器)
             */
            uniformBufferCode += `@group(0) @binding(1) var<uniform> uniforms: Uniforms;\n\n`;
        }

        /**
         * - EN: Process each pass to generate individual shader modules
         * - TW: 處理每個通道以生成個別的著色器模組
         */
        shaderInfo.passes.forEach(pass => {
            /**
             * - EN: Add generation timestamp and pass identifier
             * - TW: 加入生成時間戳記和通道識別碼
             */
            let wgsl = `// 由 WGFX 組裝器生成 - 獨特註解: ${Date.now()} - Pass ${pass.index}\n\n`;
            wgsl += commonCode;

            /**
             * - EN: Declare default sampler 'sam' (always bound to binding 0)
             * - TW: 宣告預設取樣器 'sam' (始終綁定到 binding 0)
             */
            wgsl += `@group(0) @binding(0) var sam: sampler;\n\n`;

            wgsl += uniformBufferCode;

            /**
             * - EN: Initialize resource tracking for this pass
             * - TW: 初始化此通道的資源追蹤
             */
            const passResources = {
                textures: [],
                samplers: [],
                parameters: shaderInfo.parameters
            };

            /**
             * - EN: Add default sampler 'sam' to resource list
             * - TW: 將預設取樣器 'sam' 加入資源列表
             */
            passResources.samplers.push({ name: 'sam', binding: 0, group: 0, filter: 'LINEAR' });

            /**
             * - EN: Collect textures and samplers used by this pass
             * - TW: 收集此通道使用的紋理和取樣器
             */
            const usedTextureNames = new Set([...pass.in, ...pass.out]);
            const usedSamplerNames = new Set(pass.in.filter(name => shaderInfo.samplers.some(s => s.name === name)));

            /**
             * - EN: Automatically add globally declared samplers to every pass
             * - TW: 自動將全域宣告的取樣器加入每個通道
             */
            shaderInfo.samplers.forEach(resource => {
                /**
                 * - EN: Avoid duplicates and skip 'sam' as it's already added
                 * - TW: 避免重複並跳過 'sam',因為它已經被加入
                 */
                if (resource.name !== 'sam' && !passResources.samplers.some(s => s.name === resource.name)) {
                    passResources.samplers.push(resource);
                }
            });

            /**
             * - EN: Allocate bindings for textures and samplers in this pass.
             * Start from binding 2 if uniforms exist (sam:0, uniforms:1), otherwise binding 1 (sam:0).
             * - TW: 如果有 uniforms,從 binding 2 開始 (sam:0, uniforms:1),否則從 binding 1 開始 (sam:0)。
             * 為此通道的紋理和取樣器分配綁定。
             */
            let bindingIndex = (shaderInfo.parameters.length > 0) ? 2 : 1;

            /**
             * - EN: Declare textures used by this pass
             * - TW: 宣告此通道使用的紋理
             */
            shaderInfo.textures.forEach(tex => {
                const isUsed = [...usedTextureNames].some(usedName => tex.name === usedName || tex.name.startsWith(usedName + "_"));
                if (isUsed) {
                    /**
                     * - EN: Determine if texture is storage or sampled based on naming conventions
                     * - TW: 根據命名慣例判斷紋理是儲存紋理還是取樣紋理
                     */
                    const isStorage = tex.name.endsWith('_storaged') || tex.name === 'OUTPUT';
                    const format = (tex.format || 'rgba8unorm').toLowerCase().replace(/_/g, '');
                    let textureType;

                    if (tex.name.endsWith('_sampled')) {
                        /**
                         * - EN: Heuristic: sampled textures are texture_2d<f32>
                         * - TW: 啟發式: 取樣紋理是 texture_2d<f32>
                         */
                        textureType = 'texture_2d<f32>';
                    } else if (tex.name.endsWith('_storaged')) {
                        /**
                         * - EN: Heuristic: storaged textures are texture_storage_2d
                         * - TW: 啟發式: 儲存紋理是 texture_storage_2d
                         */
                        textureType = `texture_storage_2d<${format}, write>`;
                    } else if (tex.name === 'INPUT') {
                        textureType = 'texture_2d<f32>';
                    } else if (tex.name === 'OUTPUT') {
                        textureType = `texture_storage_2d<${format}, write>`;
                    } else {
                        /**
                         * - EN: Fallback: use isStorage flag from pass usage if no clear naming convention
                         * - TW: 後備方案: 如果沒有明確的命名慣例,使用通道使用的 isStorage 標誌
                         */
                        textureType = isStorage ? `texture_storage_2d<${format}, write>` : `texture_2d<f32>`;
                    }

                    const currentBinding = bindingIndex++;
                    wgsl += `@group(0) @binding(${currentBinding}) var ${tex.name}: ${textureType};\n`;
                    passResources.textures.push({ ...tex, binding: currentBinding, group: 0, isStorage: isStorage });
                }
            });

            /**
             * - EN: Declare samplers used by this pass (excluding `sam` as it's already handled)
             * - TW: 宣告此通道使用的取樣器 (除了 `sam`,因為它已經被處理了)
             */
            shaderInfo.samplers.forEach(samp => {
                if (samp.name !== 'sam' && usedSamplerNames.has(samp.name)) {
                    const currentBinding = bindingIndex++;
                    wgsl += `@group(0) @binding(${currentBinding}) var ${samp.name}: sampler;\n`;
                    passResources.samplers.push({ ...samp, binding: currentBinding, group: 0 });
                }
            });
            wgsl += '\n';

            /**
             * - EN: Append the pass's WGSL code to the module
             * - TW: 將通道的 WGSL 程式碼附加到模組中
             */
            wgsl += `// --- 通道 ${pass.index} ---\n`;

            /**
             * - EN: Remove any remaining //! directives
             * - TW: 移除任何剩餘的 //! 指令
             */
            let processedPassCode = pass.code.replace(/\/!.*\n/g, '');
            processedPassCode = this._preprocessPassCode(processedPassCode, pass.index);

            /**
             * - EN: Default workgroup size in case not specified
             * - TW: 預設工作組大小以防未指定
             */
            const numThreads = pass.numThreads || [1, 1, 1];

            /**
             * - EN: Remove any existing @compute or @workgroup_size attributes from the passCode
             * - TW: 移除 passCode 中任何現有的 @compute 或 @workgroup_size 屬性
             */
            processedPassCode = processedPassCode.replace(/@compute\s*@workgroup_size\([^)]+\)\s*/g, '');

            /**
             * - EN: Replace fn PassX with fn main_cs (standardized entry point)
             * - TW: 將 fn PassX 替換為 fn main_cs (標準化進入點)
             */
            const passFunctionSignatureRegex = new RegExp(`fn Pass${pass.index}`);
            processedPassCode = processedPassCode.replace(
                passFunctionSignatureRegex,
                `fn main_cs `
            );

            /**
             * - EN: Prepend the @compute @workgroup_size attributes
             * - TW: 在前面加上 @compute @workgroup_size 屬性
             */
            processedPassCode = `@compute @workgroup_size(${numThreads[0]}, ${numThreads[1]}, ${numThreads[2]}) ${processedPassCode}`;

            wgsl += processedPassCode;

            /**
             * - EN: Store the generated module with metadata
             * - TW: 儲存生成的模組及其中繼資料
             */
            generatedModules.push({
                wgslCode: wgsl.replace(/\r\n/g, '\n'),
                passIndex: pass.index,
                resources: passResources
            });
        });

        return generatedModules;
    }
}

// src/runtime/UniformBinder.js

/**
 * @fileoverview
 * - EN: Handles dynamic updates of uniform buffers.
 *   This class provides a simple API for changing uniform values at runtime.
 * - TW: 處理統一緩衝區的動態更新。
 *   此類別提供一個簡單的 API，用於在運行時更改統一值。
 */

let GPUDevice;

/**
 * - EN: In a Node.js environment, native WebGPU objects don't exist.
 *   We check for their existence on the global scope. If they don't exist,
 *   `GPUDevice` will remain `undefined`, which is safe for the CLI code path
 *   as it doesn't instantiate or use any GPU-related objects.
 * - TW: 在 Node.js 環境中，原生 WebGPU 物件不存在。
 *   我們檢查它們是否在全域範圍內存在。如果不存在，
 *   `GPUDevice` 將保持 `undefined`，這對於 CLI 程式碼路徑是安全的，
 *   因為它不實例化或使用任何與 GPU 相關的物件。
 */
try {
    /**
     * - EN: This will only succeed in a browser-like environment with WebGPU support.
     * - TW: 這只會在支援 WebGPU 的瀏覽器環境中成功。
     */
    if (globalThis.GPUDevice) {
        GPUDevice = globalThis.GPUDevice;
    }
    /**
     * - EN: In Node.js or a non-WebGPU environment, this will remain undefined.
     * - TW: 在 Node.js 或非 WebGPU 環境中，這將保持未定義。
     */
} catch (e) {
    /**
     * - EN: Ignore any errors during this detection phase.
     * - TW: 在此檢測階段忽略任何錯誤。
     */
}


class UniformBinder {
    /**
     * @param {GPUDevice} [device]
     * - EN: The active WebGPU device.
     * - TW: 作用中的 WebGPU 裝置。
     * @param {import('./ResourceManager.js').ResourceManager} resourceManager
     * - EN: An instance of the resource manager.
     * - TW: 資源管理器的實例。
     */
    constructor(device, resourceManager) {
        this.device = device || new GPUDevice();
        /**
         * - EN: Use provided device or a mock device.
         * - TW: 使用提供的裝置或模擬裝置。
         */
        this.resourceManager = resourceManager;
    }

    /**
     * - EN: Dynamically updates the value of a single uniform in the shared uniform buffer.
     * - TW: 在共享統一緩衝區中動態更新單個統一的值。
     * @param {string} name
     * - EN: The name of the uniform to update (e.g., `Strength`).
     * - TW: 要更新的統一名稱 (例如：`Strength`)。
     * @param {number} value
     * - EN: The new numeric value for the uniform.
     * - TW: 統一的新數值。
     */
    updateUniform(name, value) {
        /**
         * - EN: Retrieve uniform metadata (buffer, offset, size) from the resource manager.
         * - TW: 從資源管理器獲取統一的元資料 (緩衝區、偏移量、大小)。
         */
        const uniformInfo = this.resourceManager.getUniform(name);
        if (!uniformInfo) {
            console.warn(`Uniform '${name}' not found. Cannot update. / 找不到統一 '${name}'。無法更新。`);
            return;
        }

        const {buffer, offset, size} = uniformInfo;

        /**
         * - EN: Create a temporary typed array with the new value.
         *   This implementation simplifies things, assuming all uniforms are 4-byte floats.
         *   A more robust solution would check the parameter type from the IR.
         * - TW: 使用新值建立一個臨時的類型化陣列。
         *   此實作簡化了事情，假設所有統一都是 4 位元組浮點數。
         *   更穩健的解決方案將檢查 IR 中的參數類型。
         */
        const data = new Float32Array([value]);

        if (data.byteLength > size) {
            console.error(`Data size mismatch for uniform '${name}'. Expected ${size}, but got ${data.byteLength}. / 統一 '${name}' 的資料大小不匹配。預期為 ${size}，但得到 ${data.byteLength}。`);
            return;
        }

        /**
         * - EN: Write the data to the correct position in the GPU buffer.
         * - TW: 將資料寫入 GPU 緩衝區中的正確位置。
         */
        this.device.queue.writeBuffer(
            buffer,
            /**
             * - EN: Destination buffer.
             * - TW: 目標緩衝區。
             */
            offset,
            /**
             * - EN: Byte offset to start writing from.
             * - TW: 開始寫入的位元組偏移量。
             */
            data,
            /**
             * - EN: Source data.
             * - TW: 來源資料。
             */
            0,
            /**
             * - EN: Offset within the source data.
             * - TW: 來源資料中的偏移量。
             */
            size
            /**
             * - EN: Number of bytes to write.
             * - TW: 要寫入的位元組數。
             */
        );
    }
}

// src/runtime/WGFXRuntime.js


class WGFXRuntime {
    /**
     * @param {GPUDevice} device
     * - EN: The active WebGPU device.
     * - TW: 作用中的 WebGPU 裝置。
     */
    constructor(device) {
        if (!device) {
            /**
             * - EN: WGFXRuntime requires a valid WebGPU device. No device provided.
             * - TW: WGFXRuntime 需要一個有效的 WebGPU 裝置。未提供裝置。
             */
            throw new Error("WGFXRuntime requires a valid WebGPU device. No device provided.");
        }
        this.device = device;

        /**
         * - EN: Instantiate all necessary sub-modules.
         * - TW: 實例化所有必要的子模組。
         */
        // this.parser = new ShaderParser(); // No longer needed
        this.resourceManager = new ResourceManager(this.device);
        this.pipelineManager = new PipelineManager(this.device, this.resourceManager);
        this.wgslCodeGenerator = new WGSLCodeGenerator();
        this.uniformBinder = new UniformBinder(this.device, this.resourceManager);

        /**
         * - EN: Intermediate representation of the currently compiled shader.
         * - TW: 當前編譯著色器的中介表示。
         * @type {import('./ShaderParser.js').WGFXShaderInfo | null}
         */
        this.shaderInfo = null;
    }

    /**
     * - EN: Compiles a WGFX effect from a code string. This is the main entry point for setting up a new effect.
     *   The process involves parsing, code generation, resource allocation, and pipeline creation.
     * - TW: 從程式碼字串編譯 WGFX 效果。這是設定新效果的主要入口點。
     *   該過程涉及解析、程式碼生成、資源分配和管線建立。
     * @param {string} effectCode
     * - EN: The string containing the entire WGFX effect code.
     * - TW: 包含整個 WGFX 效果程式碼的字串。
     * @returns {Promise<void>}
     * - EN: A Promise that resolves when compilation is complete.
     * - TW: 編譯完成時解析的 Promise。
     */
    async compile(effectCode, externalResources = {}) {
        // FIXME: This is a temporary solution to pass external resources.
        // A more robust solution would be to have a dedicated method to set resources.
        /**
         * - EN: Starting effect compilation.
         * - TW: 開始效果編譯。
         */
        console.log("WGFXRuntime: Starting effect compilation.");
        /**
         * - EN: 1. Parse the FX file to get the Intermediate Representation (IR).
         * - TW: 1. 解析 FX 檔案以獲取中介表示 (IR)。
         */
        this.shaderInfo = peg$parse(effectCode);
        /**
         * - EN: ShaderInfo (IR) parsed.
         * - TW: 已解析 ShaderInfo (IR)。
         */
        console.log("WGFXRuntime: ShaderInfo (IR) parsed:", this.shaderInfo);
        /**
         * - EN: 2. Generate a single WGSL shader module from the IR.
         * - TW: 2. 從 IR 生成單個 WGSL 著色器模組。
         */
        const generatedModules = this.wgslCodeGenerator.generate(this.shaderInfo);
        // if (this.parser.debug) {
        //     /**
        //      * - EN: Old debug check removed
        //      * - TW: 舊的調試檢查已移除
        //      */
        //     console.log("WGFXRuntime: Generated WGSL module:", generatedModules);
        // }

        /**
         * - EN: 3. Initialize all GPU resources (textures, samplers, buffers) based on the IR.
         * - TW: 3. 根據 IR 初始化所有 GPU 資源 (紋理、取樣器、緩衝區)。
         */
        this.resourceManager.initialize(this.shaderInfo, externalResources);
        /**
         * - EN: Resources initialized.
         * - TW: 資源已初始化。
         */
        console.log("WGFXRuntime: Resources initialized.");
        /**
         * - EN: 4. Create compute pipelines for each pass.
         * - TW: 4. 為每個通道建立計算管線。
         */
        await this.pipelineManager.createPipelines(this.shaderInfo, generatedModules);
        /**
         * - EN: Pipelines created.
         * - TW: 管線已建立。
         */
        console.log("WGFXRuntime: Pipelines created.");
        /**
         * - EN: Compilation complete.
         * - TW: 編譯完成。
         */
        console.log("WGFXRuntime: Compilation complete.");
    }

    /**
     * - EN: Encodes commands to dispatch a specific compute pass.
     * - TW: 編碼調度特定計算通道的命令。
     * @param {string} passName
     * - EN: The name of the pass to dispatch (e.g., `PASS_1`).
     * - TW: 要調度的通道名稱 (例如：`PASS_1`)。
     * @param {GPUCommandEncoder} commandEncoder
     * - EN: The command encoder for the current frame.
     * - TW: 當前幀的命令編碼器。
     */
    dispatchPass(passName, commandEncoder) {
        if (!this.shaderInfo) {
            /**
             * - EN: Effect not compiled. Call compile() first.
             * - TW: 效果未編譯。請先呼叫 compile()。
             */
            throw new Error("Effect not compiled. Call compile() first.");
        }

        /**
         * - EN: Look up the corresponding pass information from the IR.
         * - TW: 從 IR 中查找對應的通道資訊。
         */
        const passIndex = parseInt(passName.split('_')[1], 10);
        const passInfo = this.shaderInfo.passes.find(p => p.index === passIndex);
        if (!passInfo) {
            /**
             * - EN: Pass `passName` not found in shader information.
             * - TW: 在著色器資訊中找不到通道 `passName`。
             */
            throw new Error(`Pass "${passName}" not found in shader information.`);
        }

        /**
         * - EN: Delegate the actual dispatch logic to the pipeline manager.
         * - TW: 將實際的調度邏輯委託給管線管理器。
         */
        this.pipelineManager.dispatchPass(passInfo, commandEncoder);
    }

    /**
     * - EN: Updates the value of a uniform parameter in the GPU buffer.
     * - TW: 更新 GPU 緩衝區中 uniform 參數的值。
     * @param {string} name
     * - EN: The name of the uniform to update.
     * - TW: 要更新的 uniform 名稱。
     * @param {number} value
     * - EN: The new value for the uniform.
     * - TW: uniform 的新值。
     */
    updateUniform(name, value) {
        if (!this.shaderInfo) {
            /**
             * - EN: Effect not compiled. Call compile() first.
             * - TW: 效果未編譯。請先呼叫 compile()。
             */
            throw new Error("Effect not compiled. Call compile() first.");
        }
        this.uniformBinder.updateUniform(name, value);
    }

    /**
     * - EN: Gets the GPUTextureView of the final output texture, usually named 'OUTPUT'.
     * - TW: 獲取最終輸出紋理的 GPUTextureView，通常命名為 'OUTPUT'。
     * @returns {GPUTextureView}
     * - EN: The texture view of the final output.
     * - TW: 最終輸出的紋理視圖。
     */
    getOutput() {
        const outputTexture = this.resourceManager.getTexture('OUTPUT');
        if (!outputTexture) {
            /**
             * - EN: Output texture `OUTPUT` not found in ResourceManager. Ensure it is correctly defined or managed.
             * - TW: 在 ResourceManager 中找不到輸出紋理 `OUTPUT`。請確保已正確定義或管理。
             */
            throw new Error("Output texture 'OUTPUT' not found in ResourceManager. Ensure it is correctly defined or managed.");
        }
        return outputTexture.createView();
    }

    /**
     * - EN: Utility function to get raw GPU resources.
     * - TW: 獲取原始 GPU 資源的實用函數。
     * @param {string} name
     * - EN: The name of the resource.
     * - TW: 資源的名稱。
     * @returns {GPUTexture | GPUSampler | GPUBuffer | undefined}
     * - EN: The underlying GPU resource.
     * - TW: 底層 GPU 資源。
     */
    getResource(name) {
        return this.resourceManager.getTexture(name)
            || this.resourceManager.getSampler(name)
            || this.resourceManager.getUniform(name)?.buffer;
    }
}

// src/index.js


/**
 * - EN: Singleton instance of WGFXRuntime.
 * - TW: WGFXRuntime 的單例實例。
 * @type {WGFXRuntime | null}
 */
let runtimeInstance = null;

/**
 * - EN: Initializes the runtime (if needed) and compiles the WGFX effect.
 *   This function must be called before any other API functions.
 * - TW: 初始化運行時 (如果需要) 並編譯 WGFX 效果。
 *   必須在任何其他 API 函數之前呼叫此函數。
 * @param {string} effectCode
 * - EN: The string containing the entire WGFX effect code.
 * - TW: 包含整個 WGFX 效果程式碼的字串。
 * @param {GPUDevice} device
 * - EN: The active WebGPU device.
 * - TW: 作用中的 WebGPU 裝置。
 * @returns {Promise<void>}
 * - EN: A Promise that resolves when compilation is complete.
 * - TW: 編譯完成時解析的 Promise。
 */
async function compile(effectCode, device, externalResources = {}) {
    runtimeInstance = new WGFXRuntime(device);
    await runtimeInstance.compile(effectCode, externalResources);
    return runtimeInstance.shaderInfo;
}

/**
 * - EN: Encodes commands to dispatch a specific compute pass in the compiled effect.
 * - TW: 編碼調度已編譯效果中特定計算通道的命令。
 * @param {string} passName
 * - EN: The name of the pass to dispatch (e.g., 'PASS_1').
 * - TW: 要調度的通道名稱 (例如：'PASS_1')。
 * @param {GPUCommandEncoder} commandEncoder
 * - EN: The command encoder for the current frame.
 * - TW: 當前幀的命令編碼器。
 */
function dispatchPass(passName, commandEncoder) {
    if (!runtimeInstance) {
        throw new Error("WGFX runtime not initialized. Call compile() first. / WGFX 運行時未初始化。請先呼叫 compile()。");
    }
    runtimeInstance.dispatchPass(passName, commandEncoder);
}

/**
 * - EN: Updates the value of a single uniform parameter.
 * - TW: 更新單個統一參數的值。
 * @param {string} name
 * - EN: The name of the uniform to update.
 * - TW: 要更新的統一名稱。
 * @param {number} value
 * - EN: The new numeric value for the uniform.
 * - TW: 統一的新數值。
 */
function updateUniform(name, value) {
    if (!runtimeInstance) {
        throw new Error("WGFX runtime not initialized. Call compile() first. / WGFX 運行時未初始化。請先呼叫 compile()。");
    }
    runtimeInstance.updateUniform(name, value);
}

/**
 * - EN: Gets the GPUTextureView of the final output texture.
 *   By convention, this is the texture named 'OUTPUT' in the WGFX file.
 * - TW: 獲取最終輸出紋理的 GPUTextureView。
 *   按照慣例，這是 WGFX 檔案中名為 'OUTPUT' 的紋理。
 * @returns {GPUTextureView}
 * - EN: The texture view of the final output.
 * - TW: 最終輸出的紋理視圖。
 */
function getOutput() {
    if (!runtimeInstance) {
        throw new Error("WGFX runtime not initialized. Call compile() first. / WGFX 運行時未初始化。請先呼叫 compile()。");
    }
    return runtimeInstance.getOutput();
}

exports.compile = compile;
exports.dispatchPass = dispatchPass;
exports.getOutput = getOutput;
exports.updateUniform = updateUniform;
