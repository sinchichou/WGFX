<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WGFX Browser Test</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        canvas {
            border: 1px solid black;
        }

        #controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }

        .control {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }
    </style>
</head>
<body>
<h1>WGFX Browser Test</h1>
<div class="container">
    <div>
        <h2>Input</h2>
        <canvas height="720" id="input-canvas" width="1280"></canvas>
    </div>
    <div>
        <h2>Output</h2>
        <canvas height="720" id="output-canvas" width="1280"></canvas>
    </div>
</div>
<div id="controls"></div>

<script type="module">
    // This will be the browser bundle of our library
    import {WGFX} from '../dist/wgfx.browser.esm.js';

    async function main() {
        if (!navigator.gpu) {
            document.body.innerHTML = "<h1>WebGPU not supported</h1>";
            return;
        }

        const adapter = await navigator.gpu.requestAdapter();
        const device = await adapter.requestDevice();

        const outputCanvas = document.getElementById('output-canvas');
        const inputCanvas = document.getElementById('input-canvas');
        const controlsContainer = document.getElementById('controls');

        // 1. Prepare a sample input texture
        const inputCtx = inputCanvas.getContext('2d');
        inputCtx.fillStyle = 'blue';
        inputCtx.fillRect(0, 0, inputCanvas.width, inputCanvas.height);
        inputCtx.fillStyle = 'red';
        inputCtx.fillRect(inputCanvas.width / 4, inputCanvas.height / 4, inputCanvas.width / 2, inputCanvas.height / 2);

        const imageBitmap = await createImageBitmap(inputCanvas);
        const inputTexture = device.createTexture({
            size: [imageBitmap.width, imageBitmap.height, 1],
            format: 'rgba8unorm',
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
        });
        device.queue.copyExternalImageToTexture(
            {source: imageBitmap},
            {texture: inputTexture},
            [imageBitmap.width, imageBitmap.height]
        );


        // 2. Initialize WGFX
        const wgfx = new WGFX(device, outputCanvas);

        // 3. Load shader and compile
        const response = await fetch('./Anime4K_Restore_Soft_UL.wgsl');
        const wgslCode = await response.text();

        const uiControls = await wgfx.compile(wgslCode, inputTexture);

        // 4. Generate UI controls
        const uniformState = {};
        controlsContainer.innerHTML = ''; // Clear previous controls
        uiControls.forEach(control => {
            const controlEl = document.createElement('div');
            controlEl.className = 'control';

            const label = document.createElement('label');
            label.setAttribute('for', control.name);
            label.textContent = `${control.name} (${control.default}):`;

            const input = document.createElement('input');
            input.type = 'range';
            input.name = control.name;
            input.min = control.min;
            input.max = control.max;
            input.step = control.step || 0.01;
            input.value = control.default;

            const valueSpan = document.createElement('span');
            valueSpan.textContent = control.default;

            input.addEventListener('input', () => {
                uniformState[control.name] = parseFloat(input.value);
                valueSpan.textContent = input.value;
            });

            uniformState[control.name] = control.default;

            controlEl.appendChild(label);
            controlEl.appendChild(input);
            controlEl.appendChild(valueSpan);
            controlsContainer.appendChild(controlEl);
        });

        // 5. Start the render loop
        async function frame() {
            await wgfx.dispatch(uniformState);
            requestAnimationFrame(frame);
        }

        requestAnimationFrame(frame);
    }

    main().catch(err => {
        console.error(err);
        document.body.innerHTML = `<h1>Error</h1><pre>${err.message}</pre>`;
    });
</script>
</body>
</html>
