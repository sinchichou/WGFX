// @generated by Peggy 5.0.6.
//
// https://peggyjs.org/


class peg$SyntaxError extends SyntaxError {
    constructor(message, expected, found, location) {
        super(message);
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";
    }

    static buildMessage(expected, found) {
        function hex(ch) {
            return ch.codePointAt(0).toString(16).toUpperCase();
        }

        const nonPrintable = Object.prototype.hasOwnProperty.call(RegExp.prototype, "unicode")
            ? new RegExp("[\\p{C}\\p{Mn}\\p{Mc}]", "gu")
            : null;

        function unicodeEscape(s) {
            if (nonPrintable) {
                return s.replace(nonPrintable, ch => "\\u{" + hex(ch) + "}");
            }
            return s;
        }

        function literalEscape(s) {
            return unicodeEscape(s
                .replace(/\\/g, "\\\\")
                .replace(/"/g, "\\\"")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g, ch => "\\x0" + hex(ch))
                .replace(/[\x10-\x1F\x7F-\x9F]/g, ch => "\\x" + hex(ch)));
        }

        function classEscape(s) {
            return unicodeEscape(s
                .replace(/\\/g, "\\\\")
                .replace(/\]/g, "\\]")
                .replace(/\^/g, "\\^")
                .replace(/-/g, "\\-")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g, ch => "\\x0" + hex(ch))
                .replace(/[\x10-\x1F\x7F-\x9F]/g, ch => "\\x" + hex(ch)));
        }

        const DESCRIBE_EXPECTATION_FNS = {
            literal(expectation) {
                return "\"" + literalEscape(expectation.text) + "\"";
            },

            class(expectation) {
                const escapedParts = expectation.parts.map(
                    part => (Array.isArray(part)
                        ? classEscape(part[0]) + "-" + classEscape(part[1])
                        : classEscape(part))
                );

                return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]" + (expectation.unicode ? "u" : "");
            },

            any() {
                return "any character";
            },

            end() {
                return "end of input";
            },

            other(expectation) {
                return expectation.description;
            },
        };

        function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }

        function describeExpected(expected) {
            const descriptions = expected.map(describeExpectation);
            descriptions.sort();

            if (descriptions.length > 0) {
                let j = 1;
                for (let i = 1; i < descriptions.length; i++) {
                    if (descriptions[i - 1] !== descriptions[i]) {
                        descriptions[j] = descriptions[i];
                        j++;
                    }
                }
                descriptions.length = j;
            }

            switch (descriptions.length) {
                case 1:
                    return descriptions[0];

                case 2:
                    return descriptions[0] + " or " + descriptions[1];

                default:
                    return descriptions.slice(0, -1).join(", ")
                        + ", or "
                        + descriptions[descriptions.length - 1];
            }
        }

        function describeFound(found) {
            return found ? "\"" + literalEscape(found) + "\"" : "end of input";
        }

        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    }

    format(sources) {
        let str = "Error: " + this.message;
        if (this.location) {
            let src = null;
            const st = sources.find(s => s.source === this.location.source);
            if (st) {
                src = st.text.split(/\r\n|\n|\r/g);
            }
            const s = this.location.start;
            const offset_s = (this.location.source && (typeof this.location.source.offset === "function"))
                ? this.location.source.offset(s)
                : s;
            const loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
            if (src) {
                const e = this.location.end;
                const filler = "".padEnd(offset_s.line.toString().length, " ");
                const line = src[s.line - 1];
                const last = s.line === e.line ? e.column : line.length + 1;
                const hatLen = (last - s.column) || 1;
                str += "\n --> " + loc + "\n"
                    + filler + " |\n"
                    + offset_s.line + " | " + line + "\n"
                    + filler + " | " + "".padEnd(s.column - 1, " ")
                    + "".padEnd(hatLen, "^");
            } else {
                str += "\n at " + loc;
            }
        }
        return str;
    }
}

function peg$parse(input, options) {
    options = options !== undefined ? options : {};

    const peg$FAILED = {};
    const peg$source = options.grammarSource;

    const peg$startRuleFunctions = {
        start: peg$parsestart,
    };
    let peg$startRuleFunction = peg$parsestart;

    const peg$c0 = "\n";
    const peg$c1 = "//!";

    const peg$r0 = /^[^\n]/;
    const peg$r1 = /^[a-zA-Z0-9_]/;
    const peg$r2 = /^[ \t]/;

    const peg$e0 = peg$literalExpectation("\n", false);
    const peg$e1 = peg$literalExpectation("//!", false);
    const peg$e2 = peg$classExpectation(["\n"], true, false, false);
    const peg$e3 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_"], false, false, false);
    const peg$e4 = peg$classExpectation([" ", "\t"], false, false, false);

    function peg$f0() {
        // Commit the last block if it was a PASS and had accumulated code.
        // 如果最後一個區塊是 PASS 並且有累積的程式碼，則提交它。
        if (currentBlock === 'PASS' && passCodeBuffer.length > 0) {
            currentData.code = passCodeBuffer.join('\n');
        }
        // Commit any remaining current block data.
        // 提交任何剩餘的當前區塊資料。
        if (currentData) commitBlock(currentBlock, currentData);
        return shaderInfo;
    }

    function peg$f1() {
        return {type: "empty"};
    }

    function peg$f2(name, value) {
        const directive = name.toUpperCase();
        const val = value.trim();

        // Handle the 'END' directive, which explicitly closes the current block.
        // 處理 'END' 指令，它會明確關閉當前區塊。
        if (directive === 'END') {
            // If a PASS block was active, commit its accumulated code.
            // 如果 PASS 區塊處於活動狀態，則提交其累積的程式碼。
            if (currentBlock === 'PASS' && passCodeBuffer.length > 0) {
                currentData.code = passCodeBuffer.join('\n');
                passCodeBuffer = [];
            }
            // Commit any remaining current block data before ending.
            // 在結束前提交任何剩餘的當前區塊資料。
            if (currentData) {
                commitBlock(currentBlock, currentData);
            }
            currentBlock = null;
            currentData = null;
            return {type: "directive", directive: "END"};
        }

        // Check for block-starting directives.
        // 檢查區塊起始指令。
        if (["PARAMETER", "TEXTURE", "SAMPLER", "COMMON", "PASS", "VERSION", "SORT_NAME", "USE", "CAPABILITY"].includes(directive)) {
            // If we were in a PASS block, commit its code first before starting a new block.
            // 如果我們在 PASS 區塊中，則在開始新區塊之前先提交其程式碼。
            if (currentBlock === 'PASS' && passCodeBuffer.length > 0) {
                currentData.code = passCodeBuffer.join('\n');
                passCodeBuffer = [];
            }
            // Commit the data of the previous block.
            // 提交前一個區塊的資料。
            if (currentData) {
                commitBlock(currentBlock, currentData);
            }

            // Start a new block based on the directive.
            // 根據指令開始一個新區塊。
            if (["PARAMETER", "TEXTURE", "SAMPLER", "COMMON", "PASS"].includes(directive)) {
                currentBlock = directive;
                currentData = {id: val, lines: []}; // Initialize currentData for the new block.
                if (directive === 'PASS') currentData.index = parseInt(val, 10); // Special handling for PASS index.
            } else { // Global directives (VERSION, SORT_NAME, USE, CAPABILITY) are self-contained and don't start a multi-line block.
                currentBlock = null;
                currentData = null;
                commitBlock(directive, {id: val}); // Commit immediately as they are single-line directives.
            }
        } else { // This is a sub-directive within an active block.
            // If there's no active block, this sub-directive is out of place.
            // 如果沒有活動區塊，則此子指令放置不當。
            if (!currentData) throw new Error(`Directive //! ${directive} cannot be used here / 指令 //! ${directive} 不能在此處使用`);
            parseSubDirective(currentData, directive, val); // Parse the sub-directive.
        }
        return {type: "directive", directive: directive, value: val};
    }

    function peg$f3(text) {
        const lineStr = text.join("");
        const trimmedLine = lineStr.trim();

        // Special handling for resource declarations in TEXTURE, SAMPLER, PARAMETER blocks.
        // 對於 TEXTURE, SAMPLER, PARAMETER 區塊中的資源宣告進行特殊處理。
        if (currentBlock === 'TEXTURE' || currentBlock === 'SAMPLER' || currentBlock === 'PARAMETER') {
            const match = trimmedLine.match(/var\s+([a-zA-Z0-9_]+)\s*:/); // Regex to find variable declaration.
            if (match) {
                currentData.isTemplate = true; // Mark as a template for resource creation.
                const name = match[1]; // Extract the resource name.
                const newResource = {...currentData, name: name, id: name}; // Create a new resource object.
                delete newResource.lines; // These are specific to COMMON blocks.
                delete newResource.isTemplate;

                // Push the new resource to the appropriate shaderInfo array.
                // 將新資源推送到相應的 shaderInfo 陣列中。
                if (currentBlock === 'TEXTURE') {
                    shaderInfo.textures.push(newResource);
                } else if (currentBlock === 'SAMPLER') {
                    shaderInfo.samplers.push(newResource);
                } else if (currentBlock === 'PARAMETER') {
                    shaderInfo.parameters.push(newResource);
                }
                return {type: "code", text: lineStr};
            }
        }

        // Accumulate code lines for COMMON and PASS blocks.
        // 累積 COMMON 和 PASS 區塊的程式碼行。
        if (currentBlock === 'COMMON') {
            currentData.lines.push(lineStr);
        } else if (currentBlock === 'PASS') {
            passCodeBuffer.push(lineStr);
        }
        return {type: "code", text: lineStr};
    }

    let peg$currPos = options.peg$currPos | 0;
    let peg$savedPos = peg$currPos;
    const peg$posDetailsCache = [{line: 1, column: 1}];
    let peg$maxFailPos = peg$currPos;
    let peg$maxFailExpected = options.peg$maxFailExpected || [];
    let peg$silentFails = options.peg$silentFails | 0;

    let peg$result;

    if (options.startRule) {
        if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
        return input.substring(peg$savedPos, peg$currPos);
    }

    function offset() {
        return peg$savedPos;
    }

    function range() {
        return {
            source: peg$source,
            start: peg$savedPos,
            end: peg$currPos,
        };
    }

    function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description, location) {
        location = location !== undefined
            ? location
            : peg$computeLocation(peg$savedPos, peg$currPos);

        throw peg$buildStructuredError(
            [peg$otherExpectation(description)],
            input.substring(peg$savedPos, peg$currPos),
            location
        );
    }

    function error(message, location) {
        location = location !== undefined
            ? location
            : peg$computeLocation(peg$savedPos, peg$currPos);

        throw peg$buildSimpleError(message, location);
    }

    function peg$getUnicode(pos = peg$currPos) {
        const cp = input.codePointAt(pos);
        if (cp === undefined) {
            return "";
        }
        return String.fromCodePoint(cp);
    }

    function peg$literalExpectation(text, ignoreCase) {
        return {type: "literal", text, ignoreCase};
    }

    function peg$classExpectation(parts, inverted, ignoreCase, unicode) {
        return {type: "class", parts, inverted, ignoreCase, unicode};
    }

    function peg$anyExpectation() {
        return {type: "any"};
    }

    function peg$endExpectation() {
        return {type: "end"};
    }

    function peg$otherExpectation(description) {
        return {type: "other", description};
    }

    function peg$computePosDetails(pos) {
        let details = peg$posDetailsCache[pos];
        let p;

        if (details) {
            return details;
        } else {
            if (pos >= peg$posDetailsCache.length) {
                p = peg$posDetailsCache.length - 1;
            } else {
                p = pos;
                while (!peg$posDetailsCache[--p]) {
                }
            }

            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column,
            };

            while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                } else {
                    details.column++;
                }

                p++;
            }

            peg$posDetailsCache[pos] = details;

            return details;
        }
    }

    function peg$computeLocation(startPos, endPos, offset) {
        const startPosDetails = peg$computePosDetails(startPos);
        const endPosDetails = peg$computePosDetails(endPos);

        const res = {
            source: peg$source,
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column,
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column,
            },
        };
        if (offset && peg$source && (typeof peg$source.offset === "function")) {
            res.start = peg$source.offset(res.start);
            res.end = peg$source.offset(res.end);
        }
        return res;
    }

    function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
            return;
        }

        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
    }

    function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
    }

    function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(
            peg$SyntaxError.buildMessage(expected, found),
            expected,
            found,
            location
        );
    }

    function peg$parsestart() {
        let s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseline();
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseline();
        }
        peg$savedPos = s0;
        s1 = peg$f0();
        s0 = s1;

        return s0;
    }

    function peg$parseline() {
        let s0, s1;

        s0 = peg$parsedirective_line();
        if (s0 === peg$FAILED) {
            s0 = peg$parsecode_line();
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 10) {
                    s1 = peg$c0;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e0);
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$f1();
                }
                s0 = s1;
            }
        }

        return s0;
    }

    function peg$parsedirective_line() {
        let s0, s1, s2, s3, s4, s5;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c1) {
            s1 = peg$c1;
            peg$currPos += 3;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e1);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            s3 = peg$parseidentifier();
            if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                s5 = peg$parserest_of_line();
                peg$savedPos = s0;
                s0 = peg$f2(s3, s5);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }

        return s0;
    }

    function peg$parsecode_line() {
        let s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = input.charAt(peg$currPos);
        if (peg$r0.test(s2)) {
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e2);
            }
        }
        if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = input.charAt(peg$currPos);
                if (peg$r0.test(s2)) {
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e2);
                    }
                }
            }
        } else {
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 10) {
                s2 = peg$c0;
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                }
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            peg$savedPos = s0;
            s0 = peg$f3(s1);
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }

        return s0;
    }

    function peg$parseidentifier() {
        let s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = input.charAt(peg$currPos);
        if (peg$r1.test(s2)) {
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e3);
            }
        }
        if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = input.charAt(peg$currPos);
                if (peg$r1.test(s2)) {
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e3);
                    }
                }
            }
        } else {
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
        } else {
            s0 = s1;
        }

        return s0;
    }

    function peg$parserest_of_line() {
        let s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = input.charAt(peg$currPos);
        if (peg$r0.test(s2)) {
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e2);
            }
        }
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = input.charAt(peg$currPos);
            if (peg$r0.test(s2)) {
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                }
            }
        }
        s0 = input.substring(s0, peg$currPos);

        return s0;
    }

    function peg$parse_() {
        let s0, s1;

        s0 = [];
        s1 = input.charAt(peg$currPos);
        if (peg$r2.test(s1)) {
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$e4);
            }
        }
        while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = input.charAt(peg$currPos);
            if (peg$r2.test(s1)) {
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$e4);
                }
            }
        }

        return s0;
    }


    // Initialize the Intermediate Representation (IR) structure.
    // 初始化 IR 結構
    const shaderInfo = {
        metadata: {use: {}, capability: {}},
        parameters: [],
        textures: [],
        samplers: [],
        passes: [],
        commonCode: ''
    };

    // Tracks the currently active block type (e.g., 'PARAMETER', 'TEXTURE', 'PASS').
    // 追蹤當前活動的區塊類型 (例如：'PARAMETER', 'TEXTURE', 'PASS')。
    let currentBlock = null;
    // Stores data for the current block being parsed.
    // 儲存當前正在解析的區塊資料。
    let currentData = null;
    // Buffer to accumulate code lines within a 'PASS' block.
    // 用於在 'PASS' 區塊內累積程式碼行的緩衝區。
    let passCodeBuffer = [];

    /**
     * Commits the parsed data of a block to the main shaderInfo structure.
     * 將解析後的區塊資料提交到主要的 shaderInfo 結構中。
     * @param {string} blockType - The type of the block (e.g., 'PARAMETER', 'COMMON').
     * @param {object} data - The parsed data for the block.
     */
    function commitBlock(blockType, data) {
        if (!blockType || !data || data.isTemplate) {
            currentData = null;
            return;
        }
        switch (blockType) {
            case 'PARAMETER':
                shaderInfo.parameters.push(data);
                break;
            case 'COMMON':
                shaderInfo.commonCode = data.lines.join('\n');
                break;
            case 'TEXTURE':
                shaderInfo.textures.push(data);
                break;
            case 'SAMPLER':
                shaderInfo.samplers.push(data);
                break;
            case 'PASS':
                shaderInfo.passes.push(data);
                break;
            case 'VERSION':
                shaderInfo.metadata.version = parseInt(data.id, 10);
                break;
            case 'SORT_NAME':
                shaderInfo.metadata.sortName = data.id;
                break;
            case 'USE':
                data.id.split(',').forEach(f => shaderInfo.metadata.use[f.trim().toUpperCase()] = true);
                break;
            case 'CAPABILITY':
                data.id.split(',').forEach(f => shaderInfo.metadata.capability[f.trim().toUpperCase()] = true);
                break;
        }
        currentData = null;
    }

    /**
     * Parses sub-directives within a block (e.g., //! DEFAULT, //! MIN for PARAMETER).
     * 解析區塊內部的子指令 (例如 PARAMETER 的 //! DEFAULT, //! MIN)。
     * @param {object} data - The current block's data object to populate.
     * @param {string} directive - The name of the sub-directive.
     * @param {string} value - The value of the sub-directive.
     */
    function parseSubDirective(data, directive, value) {
        const key = directive.toLowerCase();
        switch (key) {
            case 'in':
            case 'out':
                data[key] = value.split(',').map(s => s.trim());
                break;
            case 'block_size':
                data.blockSize = value.split(',').map(Number);
                if (data.blockSize.length === 1) data.blockSize.push(data.blockSize[0]); // Handle single value for block_size
                break;
            case 'num_threads':
                data.numThreads = value.split(',').map(Number);
                while (data.numThreads.length < 3) data.numThreads.push(1); // Ensure 3 components for num_threads
                break;
            case 'default':
            case 'min':
            case 'max':
            case 'step':
                data[key] = parseFloat(value);
                break;
            case 'format':
                data[key] = value.toLowerCase() === 'r16g16b16a16_float' ? 'rgba16float' : value;
                break;
            default:
                data[key] = value;
        }
    }

    peg$result = peg$startRuleFunction();

    const peg$success = (peg$result !== peg$FAILED && peg$currPos === input.length);

    function peg$throw() {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input.length ? peg$getUnicode(peg$maxFailPos) : null,
            peg$maxFailPos < input.length
                ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
                : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
    }

    if (options.peg$library) {
        return /** @type {any} */ ({
            peg$result,
            peg$currPos,
            peg$FAILED,
            peg$maxFailExpected,
            peg$maxFailPos,
            peg$success,
            peg$throw: peg$success ? undefined : peg$throw,
        });
    }
    if (peg$success) {
        return peg$result;
    } else {
        peg$throw();
    }
}

const peg$allowedStartRules = [
    "start"
];

export {
    peg$allowedStartRules as StartRules,
    peg$SyntaxError as SyntaxError,
    peg$parse as parse
};
