import { WGFXShaderInfo, PassInfo, TextureInfo } from '../types/shader';
import {Logger} from '../utils/Logger';

/**
 * Generator for WGSL shader code from parsed shader information.
 * ---
 * 從解析後的著色器資訊產生符合 WebGPU 規範的 WGSL 著色器代碼。
 * 負責注入標準變數（如 Uniforms, SceneInfo）並修正自動化轉換過程中的語法差異。
 *
 * @group Core
 * @category Generators
 */
export class WGSLCodeGenerator {
    constructor() {
    }

    /**
     * Generate complete WGSL modules for each rendering pass.
     * ---
     * 為每個渲染通道產生完整的 WGSL 模組。
     * 包含注入 Uniforms 結構體、SceneInfo 場景資訊以及自動管理資源綁定（Bindings）。
     *
     * @group Generation
     * @param shaderInfo - The parsed shader metadata / 解析後的著色器元數據
     * @returns List of generated modules / 產生的模組列表（含代碼與資源映射）
     */
    public generate(shaderInfo: WGFXShaderInfo): { wgslCode: string; passIndex: number; resources: any }[] {
        const generatedModules: { wgslCode: string; passIndex: number; resources: any }[] = [];

        // 1. Prepare Common Code section / 準備共通代碼區段
        const commonCode = shaderInfo.commonCode
            ? `// --- COMMON ---\n${shaderInfo.commonCode}\n\n`
            : '';

        // 2. Generate Uniform Buffer Struct (std140 alignment)
        // 產生 Uniform 緩衝區結構體（需符合 std140 對齊規範）
        let uniformBufferCode = '';
        if (shaderInfo.parameters.length > 0) {
            uniformBufferCode += `struct Uniforms {\n`;
            shaderInfo.parameters.forEach(p => {
                const type = p.type === 'int' ? 'i32' : 'f32';
                uniformBufferCode += `    ${p.name}: ${type},\n`;
                // Add padding for 16-byte alignment per field for simplicity in this engine
                // 為了簡化對齊邏輯，每個欄位後方加入填充以維持 16 位元組對齊
                uniformBufferCode += `    _pad_${p.name}_1: f32,\n`;
                uniformBufferCode += `    _pad_${p.name}_2: f32,\n`;
                uniformBufferCode += `    _pad_${p.name}_3: f32,\n`;
            });
            uniformBufferCode += `};\n`;
            uniformBufferCode += `@group(0) @binding(1) var<uniform> uniforms: Uniforms;\n\n`;
        }

        // 3. Generate SceneInfo Binding (Global resolution data)
        // 產生場景資訊繫結（全域解析度數據）
        const sceneInfoCode = `struct SceneInfo {
    inputSize: vec2<u32>,
    inputPt: vec2<f32>,
}
@group(0) @binding(4) var<uniform> scene: SceneInfo;\n\n`;

        // 4. Process each Pass / 處理每個通道
        shaderInfo.passes.forEach(pass => {
            let wgsl = `// Pass ${pass.index} Generated by WGFX\n\n`;
            wgsl += commonCode;

            // Inject default sampler if not present / 若未定義則注入預設取樣器
            if (!commonCode.includes('var sam:') && !commonCode.includes('var sam :')) {
                wgsl += `@group(0) @binding(0) var sam: sampler;\n\n`;
            }

            wgsl += uniformBufferCode;

            if (!commonCode.includes('SceneInfo')) {
                wgsl += sceneInfoCode;
            }

            const passResources = {
                textures: [] as any[],
                samplers: [] as any[],
                parameters: shaderInfo.parameters,
                hasScene: true
            };

            // Setup binding sequence (Start at 6 to avoid conflicts with 0, 1, 4)
            // 設定綁定序列（從 6 開始以避免與預設的 0, 1, 4 衝突）
            let bindingIndex = 6;

            // Texture bindings / 紋理綁定處理
            const usedTextureNames = new Set([...pass.in, ...pass.out]);
            shaderInfo.textures.forEach(tex => {
                const isUsed = [...usedTextureNames].some(usedName =>
                    tex.name === usedName || tex.name.startsWith(usedName + "_")
                );
                if (!isUsed) return;

                const isOutputInThisPass = pass.out.includes(tex.name);
                let isStorage = (tex.name === 'OUTPUT' || isOutputInThisPass);

                const format = 'rgba16float';
                const textureType = isStorage
                    ? `texture_storage_2d<${format}, write>`
                    : `texture_2d<f32>`;

                const currentBinding = bindingIndex++;
                wgsl += `@group(0) @binding(${currentBinding}) var ${tex.name}: ${textureType};\n`;

                passResources.textures.push({
                    ...tex,
                    format: format,
                    binding: currentBinding,
                    group: 0,
                    isStorage: isStorage
                });
            });

            // Sampler bindings / 取樣器綁定處理
            shaderInfo.samplers.forEach(samp => {
                if (samp.name !== 'sam') {
                    const currentBinding = bindingIndex++;
                    wgsl += `@group(0) @binding(${currentBinding}) var ${samp.name}: sampler;\n`;
                    passResources.samplers.push({...samp, binding: currentBinding, group: 0});
                }
            });

            // Final Pass Code processing / 最終通道代碼處理
            let processedPassCode = pass.code.replace(/\/\/!.*\n/g, ''); // Remove directives / 移除指令註解
            processedPassCode = this._preprocessPassCode(processedPassCode, pass.index);

            // Rename entry point to main_cs / 將進入點函數重命名為 main_cs
            processedPassCode = processedPassCode.replace(
                new RegExp(`fn Pass${pass.index}`),
                `fn main_cs `
            );

            // Inject blockStart variable if needed (Anime4K compatibility)
            // 注入 blockStart 變數（Anime4K 相容性支援）
            if (processedPassCode.includes('blockStart') && !processedPassCode.includes('let blockStart')) {
                processedPassCode = processedPassCode.replace(/\{/, '{\n    let blockStart = workgroup_id.xy * 8u;');
            }

            // Wrap in @compute attribute / 封裝計算著色器屬性
            const numThreads = pass.numThreads || [1, 1, 1];
            processedPassCode = `@compute @workgroup_size(${numThreads[0]}, ${numThreads[1]}, ${numThreads[2]}) ${processedPassCode}`;

            wgsl += '\n' + processedPassCode;

            generatedModules.push({
                wgslCode: wgsl,
                passIndex: pass.index,
                resources: passResources
            });

            Logger.debug(`Generated WGSL for Pass ${pass.index}`);
        });

        return generatedModules;
    }

    /**
     * Preprocess pass-specific code to fix common compatibility issues.
     * ---
     * 預處理特定通道的代碼，修正常見的 WGSL 相容性問題。
     * 包含型別強制轉換（Cast）、變數重命名以及位移運算子修正。
     *
     * @internal
     * @param passCode - Original WGSL code / 原始 WGSL 代碼
     * @param passIndex - Index of the current pass / 目前通道的索引
     * @returns Processed WGSL code / 處理後的 WGSL 代碼
     */
    private _preprocessPassCode(passCode: string, passIndex: number): string {
        let processedCode = passCode;

        // Fix WGSL type error: vec2<u32> + f32 -> Needs MF2 cast
        // 修正 WGSL 型別錯誤：無法直接讓 vec2<u32> 加 f32，需轉換為 MF2 (vec2<f32>)
        processedCode = processedCode.replace(/\(gxy \+ 0\.5f\)/g, '(MF2(gxy) + 0.5f)');

        // Map common aliases to WebGPU built-ins / 將常見別名映射至 WebGPU 內建變數
        processedCode = processedCode.replace(/threadId\.x/g, 'local_id.x');

        // Fix vector bitwise shift: (vec2<u32> << u32) -> (vec2<u32> << vec2<u32>(u32))
        // WGSL requires both sides of shift operator to be the same vector type
        // 修正向量位移運算：WGSL 要求位移運算子兩側必須是相同的向量型別
        if (passIndex >= 1) {
            processedCode = processedCode.replace(
                /(Rmp8x8\(local_id\.x\)\s*<<\s*)(\d+u)/g,
                '$1vec2<u32>($2)'
            );
        }

        // Fix variable redeclarations in max() calls / 修正 max() 呼叫中的變數重複宣告
        processedCode = processedCode.replace(
            /var\s+([a-z0-9]+)\s+=\s+max\(\1,\s+MF4\(0\.0\)\);/g,
            '$1 = max($1, MF4(0.0));'
        );

        return processedCode;
    }
}