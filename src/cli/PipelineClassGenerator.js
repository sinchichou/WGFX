// src/cli/PipelineClassGenerator.js

/**
 * @fileoverview Generates a JavaScript class for managing and executing a WGFX pipeline.
 */

export class PipelineClassGenerator {
    constructor() {
    }

    /**
     * Generates a JavaScript class for the pipeline.
     * @param {import('./StaticParser.js').WGFXShaderInfo} shaderInfo - The parsed shader information.
     * @returns {string} The generated JavaScript class as a string.
     */
    generate(shaderInfo) {
        const className = this.toCamelCase(shaderInfo.metadata.sortName || 'WGFXPipeline');

        let jsCode = `// Generated by WGFX. Do not edit.

class ${className} {
    constructor(device) {
        this.device = device;
        this.pipelines = {};
        this.resources = {};
        this.bindGroupLayouts = {};
        this.pipelineLayout = null;
    }

    async init() {
        // Create pipeline layouts
        ${this.generatePipelineLayouts(shaderInfo)}

        // Create compute pipelines
        ${this.generateComputePipelines(shaderInfo)}
    }
`;

        jsCode += this.generateResourceCreationMethods(shaderInfo);
        jsCode += this.generateDispatchMethods(shaderInfo);

        jsCode += `}
`;

        return jsCode;
    }

    generatePipelineLayouts(shaderInfo) {
        let code = '';
        const groups = {};
        for (const binding of shaderInfo.bindings) {
            if (!groups[binding.group]) {
                groups[binding.group] = [];
            }
            groups[binding.group].push(binding);
        }

        const bindGroupLayoutNames = [];
        for (const groupIndex in groups) {
            const bindings = groups[groupIndex];
            const layoutName = `bindGroupLayout${groupIndex}`;
            bindGroupLayoutNames.push(layoutName);

            code += `        this.bindGroupLayouts[${groupIndex}] = this.device.createBindGroupLayout({
`;
            code += `            entries: [
`;

            for (const binding of bindings) {
                const resource = this.findResource(shaderInfo, binding.name);
                if (!resource) continue;

                code += `                {
`;
                code += `                    binding: ${binding.binding},
`;
                code += `                    visibility: GPUShaderStage.COMPUTE,
`;

                if (resource.type === 'texture') {
                    const isStorage = shaderInfo.passes.some(p => p.out.includes(binding.name));
                    if (isStorage) {
                        code += `                    storageTexture: { format: '${resource.format || 'rgba8unorm'}' },
`;
                    } else {
                        code += `                    texture: {},
`;
                    }
                } else if (resource.type === 'sampler') {
                    code += `                    sampler: { type: '${resource.filter === 'POINT' ? 'non-filtering' : 'filtering'}' },
`;
                } else if (resource.type === 'uniform') {
                    code += `                    buffer: { type: 'uniform' },
`;
                }

                code += `                },
`;
            }

            code += `            ],
        });

`;
        }

        code += `        this.pipelineLayout = this.device.createPipelineLayout({
`;
        code += `            bindGroupLayouts: [${bindGroupLayoutNames.map(name => `this.bindGroupLayouts[${name.replace('bindGroupLayout', '')}]`).join(', ')}],
        });

`;

        return code;
    }

    generateComputePipelines(shaderInfo) {
        let code = '';
        for (const pass of shaderInfo.passes) {
            code += `        const shaderModule${pass.index} = this.device.createShaderModule({ code: pass_${pass.index}_wgsl });
`;
            code += `        this.pipelines[${pass.index}] = await this.device.createComputePipelineAsync({
`;
            code += `            layout: this.pipelineLayout,
`;
            code += `            compute: {
`;
            code += `                module: shaderModule${pass.index},
`;
            code += `                entryPoint: 'main_cs',
`;
            code += `            },
`;
            code += `        });

`;
        }
        return code;
    }

    generateResourceCreationMethods(shaderInfo) {
        let code = `
    createResources(params) {
`;
        for (const texture of shaderInfo.textures) {
            if (texture.pair && texture.name.endsWith('_sampled')) {
                continue;
            }
            code += `        this.resources['${texture.name}'] = this.device.createTexture({
`;
            code += `            size: [params.${texture.width} || params.width, params.${texture.height} || params.height, 1],
`;
            code += `            format: '${texture.format || 'rgba8unorm'}',
`;
            code += `            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST,
`;
            code += `        });
`;
        }

        for (const sampler of shaderInfo.samplers) {
            code += `        this.resources['${sampler.name}'] = this.device.createSampler({
`;
            code += `            magFilter: '${sampler.filter === 'POINT' ? 'nearest' : 'linear'}',
`;
            code += `            minFilter: '${sampler.filter === 'POINT' ? 'nearest' : 'linear'}',
`;
            code += `            addressModeU: '${sampler.address || 'clamp-to-edge'}',
`;
            code += `            addressModeV: '${sampler.address || 'clamp-to-edge'}',
`;
            code += `        });
`;
        }

        if (shaderInfo.parameters.length > 0) {
            code += `        this.resources['uniforms'] = this.device.createBuffer({
`;
            code += `            size: ${shaderInfo.parameters.length * 4},
`;
            code += `            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
`;
            code += `        });
`;
        }

        code += `    }
`;
        return code;
    }

    generateDispatchMethods(shaderInfo) {
        let code = `
    dispatch(commandEncoder, params) {
`;
        if (shaderInfo.parameters.length > 0) {
            code += `        this.device.queue.writeBuffer(this.resources['uniforms'], 0, new Float32Array([${shaderInfo.parameters.map(p => `params.${p.name}`).join(', ')}]));\n\n`;
        }

        for (const pass of shaderInfo.passes) {
            code += `        // Pass ${pass.index}\n`;
            code += `        const passEncoder${pass.index} = commandEncoder.beginComputePass();\n`;
            code += `        passEncoder${pass.index}.setPipeline(this.pipelines[${pass.index}]);\n`;

            const groups = {};
            for (const binding of shaderInfo.bindings) {
                if (!groups[binding.group]) {
                    groups[binding.group] = [];
                }
                groups[binding.group].push(binding);
            }

            for (const groupIndex in groups) {
                const bindings = groups[groupIndex];
                code += `        const bindGroup${groupIndex} = this.device.createBindGroup({\n`;
                code += `            layout: this.bindGroupLayouts[${groupIndex}],\n`;
                code += `            entries: [\n`;
                for (const binding of bindings) {
                    console.log(`Finding resource for binding: ${binding.name}`);
                    const resource = this.findResource(shaderInfo, binding.name);
                    if (!resource) continue;
                    let resourceName = binding.name;
                    if (resource.type === 'texture' && resource.pair && resource.name.endsWith('_sampled')) {
                        resourceName = resource.pair;
                    }

                    code += `                {\n`;
                    code += `                    binding: ${binding.binding},\n`;
                    code += `                    resource: this.resources['${resourceName}']${resource.type === 'texture' ? '.createView()' : ''},\n`;
                    code += `                },\n`;
                }
                code += `            ],\n        });\n`;
                code += `        passEncoder${pass.index}.setBindGroup(${groupIndex}, bindGroup${groupIndex});\n`;
            }

            const numThreads = pass.numThreads || [1, 1, 1];
            code += `        passEncoder${pass.index}.dispatchWorkgroups(Math.ceil((params.width || 1) / ${numThreads[0]}), Math.ceil((params.height || 1) / ${numThreads[1]}), 1);\n`;
            code += `        passEncoder${pass.index}.end();\n\n`;
        }

        code += `    }
`;
        return code;
    }

    toCamelCase(str) {
        return str.replace(/[^a-zA-Z0-9]+(.)?/g, (m, chr) => chr ? chr.toUpperCase() : '').replace(/^./, (m) => m.toUpperCase());
    }


}
